name: DevOps Agent

on:
  push:
    branches: [main]
  issue_comment:
    types: [created]
  schedule:
    # Run health checks every 5 minutes
    - cron: '*/5 * * * *'
    # Run monitoring audit weekly (Sunday 6am UTC)
    - cron: '0 6 * * 0'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        type: choice
        options:
          - incident-response
          - view-logs
          - restart-service
          - manage-variables
          - provision-infrastructure
          - diagnose
      service:
        description: 'Service name (backend/frontend)'
        type: choice
        options:
          - backend
          - frontend
          - all
        default: 'all'
      severity:
        description: 'Incident severity (for incident-response)'
        type: choice
        options:
          - SEV1
          - SEV2
          - SEV3
        default: 'SEV2'
      description:
        description: 'Description of the issue or action'
        type: string

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

env:
  FAILURE_THRESHOLD: 2

jobs:
  # ===========================================
  # DIAGNOSTIC REQUESTS (triggered by @devops mentions)
  # ===========================================
  diagnostic-request:
    if: |
      github.event_name == 'issue_comment' &&
      !github.event.issue.pull_request &&
      (contains(github.event.comment.body, '@devops') ||
       contains(github.event.comment.body, '@DevOps'))
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Acknowledge request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --body "## ðŸ”§ DevOps Agent Responding

          **Request:** Checking production data...
          **Workflow:** [View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          Please wait while I gather the requested information."

      - name: Install Railway CLI
        run: |
          if curl -fsSL https://railway.app/install.sh | sh; then
            echo "Railway CLI installed"
          else
            echo "Failed to install Railway CLI"
            exit 1
          fi
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Run diagnostic query
        id: diagnostic
        env:
          # Project token for CLI commands
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}
          # Workspace token for GraphQL API (different from project token!)
          RAILWAY_WORKSPACE_TOKEN: ${{ secrets.RAILWAY_WORKSPACE_TOKEN }}
          RAILWAY_WORKSPACE_ID: ${{ secrets.RAILWAY_WORKSPACE_ID }}
          BACKEND_URL: ${{ secrets.PRODUCTION_BACKEND_URL }}
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          echo "Processing diagnostic request..."

          # Check Railway CLI version
          echo "=== Railway CLI Info ===" > /tmp/diagnostic_output.txt
          railway --version >> /tmp/diagnostic_output.txt 2>&1 || echo "Railway CLI not available" >> /tmp/diagnostic_output.txt

          echo "" >> /tmp/diagnostic_output.txt
          echo "=== Service Status ===" >> /tmp/diagnostic_output.txt
          timeout 15 railway status 2>&1 >> /tmp/diagnostic_output.txt || echo "Unable to get status" >> /tmp/diagnostic_output.txt

          # Query Railway API to list projects with environments
          echo "" >> /tmp/diagnostic_output.txt
          echo "=== Railway API - Projects & Environments ===" >> /tmp/diagnostic_output.txt
          PROJECTS_RESPONSE=$(curl -s -X POST https://backboard.railway.app/graphql/v2 \
            -H "Authorization: Bearer $RAILWAY_WORKSPACE_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"query\": \"query { workspace(workspaceId: \\\"$RAILWAY_WORKSPACE_ID\\\") { projects { edges { node { id name environments { edges { node { id name } } } services { edges { node { id name } } } } } } } }\"}")
          echo "$PROJECTS_RESPONSE" >> /tmp/diagnostic_output.txt

          # Extract environment ID for thinkers-chat production (or first production env found)
          # The project name is "thinkers-chat" based on earlier discovery
          PROD_ENV_ID=$(echo "$PROJECTS_RESPONSE" | jq -r '.data.workspace.projects.edges[] | select(.node.name == "thinkers-chat") | .node.environments.edges[] | select(.node.name == "production") | .node.id' 2>/dev/null | head -1)

          if [ -n "$PROD_ENV_ID" ] && [ "$PROD_ENV_ID" != "null" ]; then
            echo "" >> /tmp/diagnostic_output.txt
            echo "=== Environment Logs (production: $PROD_ENV_ID) ===" >> /tmp/diagnostic_output.txt

            # Fetch recent logs using environmentLogs query (200 entries for deeper investigation)
            LOGS_RESPONSE=$(curl -s -X POST https://backboard.railway.app/graphql/v2 \
              -H "Authorization: Bearer $RAILWAY_WORKSPACE_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"query\": \"query { environmentLogs(environmentId: \\\"$PROD_ENV_ID\\\", beforeLimit: 200) { ... on Log { message timestamp severity } } }\"}")

            # Parse and format logs (most recent first, show last 50 by default)
            LOG_COUNT=$(echo "$LOGS_RESPONSE" | jq -r '.data.environmentLogs | length' 2>/dev/null || echo "0")
            echo "Found $LOG_COUNT log entries (showing last 50):" >> /tmp/diagnostic_output.txt
            echo "" >> /tmp/diagnostic_output.txt
            echo "$LOGS_RESPONSE" | jq -r '.data.environmentLogs[-50:]? | reverse | .[]? | "\(.timestamp) [\(.severity)] \(.message)"' 2>/dev/null >> /tmp/diagnostic_output.txt || echo "Failed to parse logs: $LOGS_RESPONSE" >> /tmp/diagnostic_output.txt
          else
            echo "" >> /tmp/diagnostic_output.txt
            echo "=== Recent Backend Logs ===" >> /tmp/diagnostic_output.txt
            echo "Could not find production environment ID. Projects response above." >> /tmp/diagnostic_output.txt
          fi

          # If the request mentions a specific user, try to find relevant logs (filter from already-fetched logs)
          if echo "$COMMENT_BODY" | grep -qi "user\|username"; then
            echo "" >> /tmp/diagnostic_output.txt
            echo "=== User-Related Logs ===" >> /tmp/diagnostic_output.txt
            if [ -n "$LOGS_RESPONSE" ]; then
              echo "$LOGS_RESPONSE" | jq -r '.data.environmentLogs[]? | "\(.timestamp) [\(.severity)] \(.message)"' 2>/dev/null | grep -i "user\|auth\|login\|register" | tail -20 >> /tmp/diagnostic_output.txt || echo "No user-related logs found in recent logs" >> /tmp/diagnostic_output.txt
            else
              echo "No logs available to filter" >> /tmp/diagnostic_output.txt
            fi
          fi

          # If the request mentions database or DB
          if echo "$COMMENT_BODY" | grep -qi "database\|db\|postgres"; then
            echo "" >> /tmp/diagnostic_output.txt
            echo "=== Database Connection Status ===" >> /tmp/diagnostic_output.txt
            # Check health endpoint which includes DB status
            if [ -n "$BACKEND_URL" ]; then
              curl -s "$BACKEND_URL/health/ready" 2>&1 >> /tmp/diagnostic_output.txt || echo "Health check unavailable" >> /tmp/diagnostic_output.txt
            else
              echo "PRODUCTION_BACKEND_URL not configured" >> /tmp/diagnostic_output.txt
            fi
          fi

          # Output for next step
          DIAGNOSTIC_OUTPUT=$(cat /tmp/diagnostic_output.txt)
          echo "output<<EOF" >> $GITHUB_OUTPUT
          echo "$DIAGNOSTIC_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post diagnostic results
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DIAGNOSTIC_OUTPUT: ${{ steps.diagnostic.outputs.output }}
        run: |
          # Write comment body to file to avoid shell escaping issues
          cat > /tmp/comment_body.md << 'COMMENT_EOF'
          ## ðŸ”§ DevOps Diagnostic Results

          <details>
          <summary>ðŸ“‹ Diagnostic Output (click to expand)</summary>

          ```
          COMMENT_EOF
          echo "$DIAGNOSTIC_OUTPUT" >> /tmp/comment_body.md
          cat >> /tmp/comment_body.md << 'COMMENT_EOF'
          ```

          </details>

          ---
          **Need more info?** You can request:
          - `@devops check user <username>` - Look for user-related logs
          - `@devops check database` - Check DB connection status
          - `@devops check logs <service>` - Get recent logs for a service

          **Note:** For direct database queries, use `railway connect postgres` locally with your Railway token.
          COMMENT_EOF
          gh issue comment ${{ github.event.issue.number }} --body-file /tmp/comment_body.md

  # ===========================================
  # HEALTH MONITORING (runs every 5 minutes)
  # ===========================================
  smoke-test:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      healthy: ${{ steps.summary.outputs.healthy }}
      failures: ${{ steps.summary.outputs.failures }}

    steps:
      - uses: actions/checkout@v4

      - name: Check backend health endpoint
        id: backend_health
        continue-on-error: true
        run: |
          BACKEND_URL="${{ secrets.PRODUCTION_BACKEND_URL }}"
          if [ -z "$BACKEND_URL" ]; then
            echo "PRODUCTION_BACKEND_URL not set"
            echo "status=skip" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Checking $BACKEND_URL/health..."
          RESPONSE=$(curl -s -w "\n%{http_code}" --max-time 15 "$BACKEND_URL/health" 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)

          echo "status=$HTTP_CODE" >> $GITHUB_OUTPUT
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Backend health check failed: HTTP $HTTP_CODE"
            exit 1
          fi
          echo "Backend health: OK"

      - name: Check frontend loads
        id: frontend
        continue-on-error: true
        run: |
          FRONTEND_URL="${{ secrets.PRODUCTION_FRONTEND_URL }}"
          if [ -z "$FRONTEND_URL" ]; then
            echo "status=skip" >> $GITHUB_OUTPUT
            exit 0
          fi

          RESPONSE=$(curl -s -w "\n%{http_code}" --max-time 15 "$FRONTEND_URL" 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          echo "status=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Frontend check failed: HTTP $HTTP_CODE"
            exit 1
          fi
          echo "Frontend: OK"

      - name: Test auth flow
        id: auth_test
        continue-on-error: true
        run: |
          BACKEND_URL="${{ secrets.PRODUCTION_BACKEND_URL }}"
          if [ -z "$BACKEND_URL" ]; then
            echo "status=skip" >> $GITHUB_OUTPUT
            exit 0
          fi

          TEST_USER="canary_$(date +%s)_$RANDOM"
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$BACKEND_URL/api/auth/register" \
            -H "Content-Type: application/json" \
            -d "{\"username\": \"$TEST_USER\", \"display_name\": \"Canary\", \"password\": \"canarypass123\"}" \
            --max-time 30 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          echo "status=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Auth test failed: HTTP $HTTP_CODE"
            exit 1
          fi
          echo "Auth flow: OK"

      - name: Check for stuck PRs and issues
        id: stuck_check
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ” Checking for stuck PRs and issues..."
          STUCK_ITEMS=""
          MERGED_COUNT=0

          # Get list of open PRs
          PR_NUMBERS=$(gh pr list --state open --json number --jq '.[].number' 2>/dev/null || echo "")

          for PR_NUM in $PR_NUMBERS; do
            [ -z "$PR_NUM" ] && continue
            PR_TITLE=$(gh pr view "$PR_NUM" --json title --jq '.title' 2>/dev/null || echo "Unknown")

            # Check if PR CI is passing (all non-skipped checks succeeded)
            CI_STATUS=$(gh pr checks "$PR_NUM" --json state --jq '[.[] | select(.state != "SKIPPED")] | if length == 0 then false else all(.state == "SUCCESS") end' 2>/dev/null || echo "false")

            if [ "$CI_STATUS" = "true" ]; then
              # Check if mergeable
              MERGEABLE=$(gh pr view "$PR_NUM" --json mergeable --jq '.mergeable' 2>/dev/null || echo "UNKNOWN")
              if [ "$MERGEABLE" = "MERGEABLE" ]; then
                echo "âš ï¸ Stuck PR #$PR_NUM: $PR_TITLE - CI passing but not merged"
                STUCK_ITEMS="${STUCK_ITEMS}PR #${PR_NUM}: ${PR_TITLE} (CI passing, ready to merge)\n"

                # Auto-merge if it's been ready
                if gh pr merge "$PR_NUM" --squash --delete-branch 2>/dev/null; then
                  echo "âœ… Auto-merged PR #$PR_NUM"
                  MERGED_COUNT=$((MERGED_COUNT + 1))
                else
                  echo "Could not auto-merge PR #$PR_NUM (may need review or have conflicts)"
                fi
              elif [ "$MERGEABLE" = "CONFLICTING" ]; then
                echo "âš ï¸ PR #$PR_NUM has conflicts: $PR_TITLE"
                STUCK_ITEMS="${STUCK_ITEMS}PR #${PR_NUM}: ${PR_TITLE} (has merge conflicts)\n"
              fi
            fi
          done

          # Check for issues stuck with needs-human label without recent activity
          ONE_HOUR_AGO=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)
          STUCK_ISSUES=$(gh issue list --label "needs-human" --json number,title,updatedAt --jq '.[] | select(.updatedAt < "'"$ONE_HOUR_AGO"'") | "Issue #\(.number): \(.title)"' 2>/dev/null || echo "")
          if [ -n "$STUCK_ISSUES" ]; then
            STUCK_ITEMS="${STUCK_ITEMS}${STUCK_ISSUES}\n"
            echo "âš ï¸ Issues stuck with needs-human label:"
            echo "$STUCK_ISSUES"
          fi

          # Output results
          if [ -n "$STUCK_ITEMS" ]; then
            echo "stuck=true" >> $GITHUB_OUTPUT
            echo "merged=$MERGED_COUNT" >> $GITHUB_OUTPUT
            echo "items<<EOF" >> $GITHUB_OUTPUT
            echo -e "$STUCK_ITEMS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "stuck=false" >> $GITHUB_OUTPUT
            echo "merged=$MERGED_COUNT" >> $GITHUB_OUTPUT
            echo "âœ… No stuck PRs or issues found"
          fi

      - name: Summarize results
        id: summary
        run: |
          FAILURES=""
          HEALTHY="true"

          [ "${{ steps.backend_health.outcome }}" == "failure" ] && FAILURES="${FAILURES}backend," && HEALTHY="false"
          [ "${{ steps.frontend.outcome }}" == "failure" ] && FAILURES="${FAILURES}frontend," && HEALTHY="false"
          [ "${{ steps.auth_test.outcome }}" == "failure" ] && FAILURES="${FAILURES}auth," && HEALTHY="false"

          FAILURES=$(echo "$FAILURES" | sed 's/,$//')
          echo "healthy=$HEALTHY" >> $GITHUB_OUTPUT
          echo "failures=$FAILURES" >> $GITHUB_OUTPUT

  # ===========================================
  # INCIDENT CREATION (when health checks fail)
  # ===========================================
  create-incident:
    needs: smoke-test
    if: needs.smoke-test.outputs.healthy == 'false'
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - name: Install Railway CLI
        continue-on-error: true
        run: |
          # Retry logic for Railway CLI installation (GitHub API can be flaky)
          for attempt in 1 2 3; do
            echo "Railway CLI install attempt $attempt..."
            if curl -fsSL https://railway.app/install.sh | sh; then
              echo "Railway CLI installed successfully"
              break
            fi
            if [ $attempt -lt 3 ]; then
              sleep $((2 ** attempt))
            else
              echo "Warning: Railway CLI installation failed after 3 attempts"
            fi
          done
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Check for existing incident
        id: check_existing
        run: |
          EXISTING=$(gh issue list --label "production-incident" --state open \
            --json number --jq '.[0].number' 2>/dev/null || echo "")
          echo "exists=$( [ -n "$EXISTING" ] && echo true || echo false )" >> $GITHUB_OUTPUT
          echo "issue_number=$EXISTING" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect Railway logs
        id: railway_logs
        continue-on-error: true
        run: |
          # Get last 30 lines of logs from each service (use -n flag to avoid streaming)
          BACKEND_LOGS=$(railway logs --service backend -n 30 2>&1 || echo "Unable to fetch backend logs")
          FRONTEND_LOGS=$(railway logs --service frontend -n 30 2>&1 || echo "Unable to fetch frontend logs")

          echo "backend_logs<<EOF" >> $GITHUB_OUTPUT
          echo "$BACKEND_LOGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "frontend_logs<<EOF" >> $GITHUB_OUTPUT
          echo "$FRONTEND_LOGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}

      - name: Update or create incident
        id: incident
        run: |
          FAILURES="${{ needs.smoke-test.outputs.failures }}"

          if [ "${{ steps.check_existing.outputs.exists }}" == "true" ]; then
            gh issue comment "${{ steps.check_existing.outputs.issue_number }}" --body "## ðŸ”„ Still Failing

          **Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Failed:** $FAILURES
          [View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          else
            SEVERITY="SEV2"
            echo "$FAILURES" | grep -q "backend" && SEVERITY="SEV1"

            # Create issue WITHOUT ai-ready label first
            ISSUE_URL=$(gh issue create \
              --title "ðŸš¨ Production Incident: $FAILURES failing" \
              --label "bug,priority-high,production-incident" \
              --body "## ðŸš¨ Production Incident

          **Severity:** $SEVERITY
          **Failed Checks:** $FAILURES
          **Detected:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          ### Railway Logs (last 30 lines)

          <details>
          <summary>Backend Logs</summary>

          \`\`\`
          ${{ steps.railway_logs.outputs.backend_logs }}
          \`\`\`
          </details>

          <details>
          <summary>Frontend Logs</summary>

          \`\`\`
          ${{ steps.railway_logs.outputs.frontend_logs }}
          \`\`\`
          </details>

          ### Actions
          - [View workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - Check Railway dashboard for more details
          - Use \`railway logs --service backend\` locally for full logs

          ---
          *Auto-created by DevOps Agent*")

            # Extract issue number from URL
            ISSUE_NUM=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')
            echo "issue_number=$ISSUE_NUM" >> $GITHUB_OUTPUT
            echo "created=true" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Trigger Code Agent for incident
        if: steps.incident.outputs.created == 'true'
        run: |
          # Post @code comment to trigger Code Agent (cleaner than label approach)
          # MUST use PAT so the comment triggers Code Agent workflow
          gh issue comment ${{ steps.incident.outputs.issue_number }} \
            --body "@code This is a production incident. Please investigate immediately using the Railway logs above and fix the issue."
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}

  # ===========================================
  # MANUAL ACTIONS (workflow_dispatch)
  # ===========================================
  manual-action:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Install Railway CLI
        continue-on-error: true
        run: |
          # Retry logic for Railway CLI installation (GitHub API can be flaky)
          for attempt in 1 2 3; do
            echo "Railway CLI install attempt $attempt..."
            if curl -fsSL https://railway.app/install.sh | sh; then
              echo "Railway CLI installed successfully"
              break
            fi
            if [ $attempt -lt 3 ]; then
              sleep $((2 ** attempt))
            else
              echo "Warning: Railway CLI installation failed after 3 attempts"
            fi
          done
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Link Railway project
        continue-on-error: true
        run: |
          # Railway CLI auto-detects project from RAILWAY_TOKEN in CI mode
          railway status || echo "Railway not linked - some features may be limited"
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}

      - name: Run DevOps Agent
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            Read CLAUDE.md first.

            ## DevOps Action Request

            **Action:** ${{ github.event.inputs.action }}
            **Service:** ${{ github.event.inputs.service }}
            **Severity:** ${{ github.event.inputs.severity }}
            **Description:** ${{ github.event.inputs.description }}

            ## Available Railway CLI Commands

            You have access to the Railway CLI. Key commands:

            ### Viewing Logs
            Use the `-n` flag to limit output and avoid indefinite streaming:
            ```bash
            railway logs --service backend -n 50     # Get last 50 lines from backend
            railway logs --service frontend -n 50    # Get last 50 lines from frontend
            railway logs -n 100                      # All services, more lines
            railway logs --build                     # Build logs
            ```

            ### Service Management
            ```bash
            railway status                         # Project status
            railway redeploy                       # Redeploy latest
            railway down                           # Remove last deployment (CAREFUL!)
            ```

            ### Environment Variables
            ```bash
            railway variables                      # List all variables
            railway variables --set "KEY=value"    # Set a variable
            railway variables --service backend    # Service-specific vars
            ```

            ### Database Access
            ```bash
            railway connect postgres               # Open psql shell
            ```

            ### Provisioning New Infrastructure
            ```bash
            railway add --database postgres        # Add PostgreSQL
            railway add --database redis           # Add Redis
            railway add --service myservice        # Add empty service
            ```

            ## Action-Specific Instructions

            ### For "incident-response":
            1. Check health endpoints with curl
            2. Get Railway logs: `railway logs --service backend -n 100`
            3. Look for errors, exceptions, connection issues
            4. Check recent deployments: `gh run list --limit 10`
            5. If code issue: create a fix PR
            6. If infra issue: check Railway dashboard, restart if needed
            7. Document findings in issue comment
            8. Escalate SEV1 to @your-github-username

            ### For "view-logs":
            1. Run `railway logs --service ${{ github.event.inputs.service }} -n 100`
            2. Look for patterns: errors, warnings, slow queries
            3. Summarize findings in a new issue or comment

            ### For "restart-service":
            1. First check current status: `railway status`
            2. Get current logs to document state before restart
            3. Run `railway redeploy` (this deploys the latest successful build)
            4. Wait 60 seconds, then verify health endpoints
            5. Document the restart in an issue comment

            ### For "manage-variables":
            1. List current variables: `railway variables`
            2. If adding/changing: `railway variables --set "KEY=value"`
            3. Document changes (but never log sensitive values!)
            4. Note: Variable changes may require redeploy

            ### For "provision-infrastructure":
            1. ONLY provision if explicitly requested in description
            2. Available: `railway add --database postgres|mysql|redis|mongo`
            3. Document what was provisioned
            4. Update any necessary environment variables
            5. Create issue to track the new resource

            ### For "diagnose":
            1. Check health endpoints using the URLs from environment variables:
               - Backend: $PRODUCTION_BACKEND_URL/health
               - Frontend: $PRODUCTION_FRONTEND_URL
               **IMPORTANT:** Do NOT try to reach custom domains (e.g., example.com) directly -
               GitHub Actions runners have network restrictions that cause false DNS failures.
               Always use the Railway URLs from the environment variables.
            2. Get logs from all services
            3. Check recent CI runs
            4. Look at recent commits
            5. Check Railway status
            6. Compile a diagnostic report

            ## Important Rules

            - NEVER expose secrets or tokens in logs/comments
            - Document all actions taken in GitHub issues
            - For destructive actions (railway down), confirm twice and document
            - Escalate to human for: security issues, data loss risk, unclear situations
            - After any fix, verify health endpoints are working

          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_args: |
            --model claude-opus-4-5-20251101
            --dangerously-skip-permissions
            --allowedTools "Bash(railway:*),Bash(gh:*),Bash(curl:*),Bash(git:*),Read,Glob,Grep"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}
          PRODUCTION_BACKEND_URL: ${{ secrets.PRODUCTION_BACKEND_URL }}
          PRODUCTION_FRONTEND_URL: ${{ secrets.PRODUCTION_FRONTEND_URL }}

  # ===========================================
  # WEEKLY MONITORING AUDIT (ensures completeness)
  # ===========================================
  monitoring-audit:
    if: github.event_name == 'schedule' && github.event.schedule == '0 6 * * 0'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Install Railway CLI
        continue-on-error: true
        run: |
          # Retry logic for Railway CLI installation (GitHub API can be flaky)
          for attempt in 1 2 3; do
            echo "Railway CLI install attempt $attempt..."
            if curl -fsSL https://railway.app/install.sh | sh; then
              echo "Railway CLI installed successfully"
              break
            fi
            if [ $attempt -lt 3 ]; then
              sleep $((2 ** attempt))
            else
              echo "Warning: Railway CLI installation failed after 3 attempts"
            fi
          done
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Run Monitoring Audit
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            Read CLAUDE.md first.

            ## Weekly Monitoring & Dashboard Audit

            Your task is to audit the monitoring and observability setup and ensure it's complete.

            ### Audit Checklist

            1. **Health Endpoints**
               - Check all services have /health endpoints responding
               - Verify health check frequency is appropriate (every 5 min)
               - Ensure health checks cover critical dependencies (DB, cache, etc.)

            2. **Logging**
               - Run `railway logs --service backend -n 50` and `railway logs --service frontend -n 50`
               - Use the `-n` flag to limit output and avoid indefinite streaming
               - Check logs have proper structure (timestamps, levels, context)
               - Look for any recurring errors that need attention

            3. **Alerting**
               - Review existing GitHub issues labeled `production-incident`
               - Check if incidents are being created when health checks fail
               - Verify escalation path is documented in CLAUDE.md

            4. **Dashboard Completeness**
               - Check Railway dashboard has all services visible
               - Verify environment variables are properly set
               - Review recent deployments for any failures

            5. **Documentation**
               - Ensure CLAUDE.md has accurate runbook for common issues
               - Verify DevOps section documents all available actions
               - Check secrets list is complete

            ### Actions to Take

            - If monitoring gaps found: Create GitHub issue with `monitoring` label
            - If dashboard incomplete: Document what's missing in an issue
            - If alerts missing: Update devops.yml or create issue
            - If everything OK: Create brief status comment on tracking issue (if exists)

            ### Output

            Create a GitHub issue titled "ðŸ“Š Weekly Monitoring Audit - [DATE]" with:
            - Summary of audit findings
            - List of any gaps or issues found
            - Recommendations for improvements
            - Status: âœ… Complete / âš ï¸ Needs Attention / âŒ Critical Issues

          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_args: |
            --model claude-sonnet-4-20250514
            --dangerously-skip-permissions
            --allowedTools "Bash(railway:*),Bash(gh:*),Bash(curl:*),Read,Glob,Grep"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}

  # ===========================================
  # FEEDBACK-TO-ISSUE PROCESSING (runs every 5 minutes)
  # ===========================================
  process-feedback:
    if: github.event_name == 'schedule' && github.event.schedule == '*/5 * * * *'
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - name: Fetch pending feedback
        id: fetch
        run: |
          BACKEND_URL="${{ secrets.PRODUCTION_BACKEND_URL }}"
          SECRET="${{ secrets.FEEDBACK_PROCESSOR_SECRET }}"

          if [ -z "$BACKEND_URL" ] || [ -z "$SECRET" ]; then
            echo "âš ï¸ PRODUCTION_BACKEND_URL or FEEDBACK_PROCESSOR_SECRET not configured"
            echo "has_feedback=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Fetching pending feedback from $BACKEND_URL/api/feedback/pending..."
          RESPONSE=$(curl -s -w "\n%{http_code}" --max-time 30 \
            "$BACKEND_URL/api/feedback/pending?secret=$SECRET&limit=10" 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::warning::Failed to fetch pending feedback: HTTP $HTTP_CODE"
            echo "Response: $BODY"
            echo "has_feedback=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          COUNT=$(echo "$BODY" | jq -r '.count // 0')
          echo "Found $COUNT pending feedback items"

          if [ "$COUNT" -eq 0 ]; then
            echo "has_feedback=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_feedback=true" >> $GITHUB_OUTPUT
          echo "count=$COUNT" >> $GITHUB_OUTPUT
          echo "feedbacks<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub issues from feedback
        if: steps.fetch.outputs.has_feedback == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          BACKEND_URL: ${{ secrets.PRODUCTION_BACKEND_URL }}
          SECRET: ${{ secrets.FEEDBACK_PROCESSOR_SECRET }}
          FEEDBACKS: ${{ steps.fetch.outputs.feedbacks }}
        run: |
          echo "Processing ${{ steps.fetch.outputs.count }} feedback items..."

          echo "$FEEDBACKS" | jq -c '.feedbacks[]' | while read -r feedback; do
            FEEDBACK_ID=$(echo "$feedback" | jq -r '.id')
            FEEDBACK_TYPE=$(echo "$feedback" | jq -r '.feedback_type')
            MESSAGE=$(echo "$feedback" | jq -r '.message')
            EMAIL=$(echo "$feedback" | jq -r '.email // "Not provided"')
            NAME=$(echo "$feedback" | jq -r '.name // "Anonymous"')
            USER_AGENT=$(echo "$feedback" | jq -r '.user_agent // "Not provided"')
            CREATED_AT=$(echo "$feedback" | jq -r '.created_at')

            echo "Processing feedback $FEEDBACK_ID (type: $FEEDBACK_TYPE)..."

            # Determine labels based on feedback type
            if [ "$FEEDBACK_TYPE" = "bug" ]; then
              LABELS="bug,priority-medium,user-feedback"
              TITLE_PREFIX="ðŸ› [User Bug Report]"
            elif [ "$FEEDBACK_TYPE" = "feature" ]; then
              LABELS="enhancement,priority-medium,user-feedback"
              TITLE_PREFIX="ðŸ’¡ [User Feature Request]"
            else
              LABELS="question,priority-low,user-feedback"
              TITLE_PREFIX="ðŸ’¬ [User Feedback]"
            fi

            # Create title from first 80 chars of message
            TITLE_MSG=$(echo "$MESSAGE" | head -c 80 | tr '\n' ' ')
            if [ ${#MESSAGE} -gt 80 ]; then
              TITLE_MSG="${TITLE_MSG}..."
            fi

            # Create the GitHub issue using printf to build the body
            {
              printf '%s\n' "## User Feedback"
              printf '\n'
              printf '%s\n' "**Submitted by:** $NAME ($EMAIL)"
              printf '%s\n' "**Type:** $FEEDBACK_TYPE"
              printf '%s\n' "**Submitted:** $CREATED_AT"
              printf '\n'
              printf '%s\n' "### Message"
              printf '\n'
              printf '%s\n' "$MESSAGE"
              printf '\n'
              printf '%s\n' "---"
              printf '\n'
              printf '%s\n' "### Browser/Device Info"
              printf '\n'
              printf '%s\n' '```'
              printf '%s\n' "$USER_AGENT"
              printf '%s\n' '```'
              printf '\n'
              printf '%s\n' "---"
              printf '%s\n' "_This issue was automatically created from user feedback._"
              printf '%s\n' "_Feedback ID: ${FEEDBACK_ID}_"
            } > /tmp/issue_body.md

            ISSUE_URL=$(gh issue create \
              --title "$TITLE_PREFIX $TITLE_MSG" \
              --label "$LABELS" \
              --body-file /tmp/issue_body.md 2>&1)

            if [ $? -eq 0 ]; then
              echo "âœ… Created issue: $ISSUE_URL"

              # Mark feedback as processed with the issue URL
              PATCH_RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
                --max-time 30 \
                -H "Content-Type: application/json" \
                -d "{\"github_issue_url\": \"$ISSUE_URL\"}" \
                "$BACKEND_URL/api/feedback/$FEEDBACK_ID/processed?secret=$SECRET" 2>&1)
              PATCH_CODE=$(echo "$PATCH_RESPONSE" | tail -n1)

              if [ "$PATCH_CODE" = "200" ]; then
                echo "âœ… Marked feedback $FEEDBACK_ID as processed"
              else
                echo "::warning::Failed to mark feedback $FEEDBACK_ID as processed (HTTP $PATCH_CODE)"
              fi
            else
              echo "::error::Failed to create issue for feedback $FEEDBACK_ID: $ISSUE_URL"
            fi
          done

          echo "Feedback processing complete!"

  # ===========================================
  # AUTO-REBASE (triggered on push to main)
  # ===========================================
  auto-rebase:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Auto-rebase conflicting PRs
        env:
          # MUST use PAT to trigger other workflows when re-adding ai-ready label
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "ðŸ”„ Checking for PRs with merge conflicts after push to main..."
          echo "   Repository: $GITHUB_REPOSITORY"

          # Wait for GitHub to compute mergeable status after push
          echo "   Waiting 10s for GitHub to update PR status..."
          sleep 10

          # Get all open PR numbers
          PR_NUMBERS=$(gh pr list --repo "$GITHUB_REPOSITORY" --state open --json number --jq '.[].number' 2>/dev/null)

          if [ -z "$PR_NUMBERS" ]; then
            echo "âœ… No open PRs to check"
            exit 0
          fi

          echo "   Open PRs: $PR_NUMBERS"

          REBASED_COUNT=0
          FAILED_COUNT=0

          for PR_NUM in $PR_NUMBERS; do
            [ -z "$PR_NUM" ] && continue

            # Query each PR individually for accurate mergeable status
            PR_INFO=$(gh pr view "$PR_NUM" --repo "$GITHUB_REPOSITORY" --json title,headRefName,mergeable 2>/dev/null)
            PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
            PR_BRANCH=$(echo "$PR_INFO" | jq -r '.headRefName')
            MERGEABLE=$(echo "$PR_INFO" | jq -r '.mergeable')

            echo "   Checking PR #$PR_NUM: mergeable=$MERGEABLE"

            # If still UNKNOWN, wait and retry once
            if [ "$MERGEABLE" = "UNKNOWN" ]; then
              echo "   Status UNKNOWN, waiting 5s and retrying..."
              sleep 5
              MERGEABLE=$(gh pr view "$PR_NUM" --repo "$GITHUB_REPOSITORY" --json mergeable --jq '.mergeable' 2>/dev/null)
              echo "   Retry result: mergeable=$MERGEABLE"
            fi

            # Check if PR has conflicts
            if [ "$MERGEABLE" = "CONFLICTING" ]; then
              echo "ðŸ”§ PR #$PR_NUM has conflicts: $PR_TITLE"
              echo "   Branch: $PR_BRANCH"

              # Fetch the PR branch
              if ! git fetch origin "$PR_BRANCH" 2>&1; then
                echo "   âŒ Could not fetch branch $PR_BRANCH"
                continue
              fi

              # Try to rebase
              if ! git checkout "$PR_BRANCH" 2>&1; then
                echo "   âŒ Could not checkout branch $PR_BRANCH"
                continue
              fi

              if git rebase origin/main 2>&1; then
                # Rebase succeeded - force push
                if git push --force-with-lease origin "$PR_BRANCH" 2>&1; then
                  echo "   âœ… Successfully rebased and pushed PR #$PR_NUM"
                  gh pr comment "$PR_NUM" --repo "$GITHUB_REPOSITORY" --body "Auto-rebased this PR onto main to resolve merge conflicts." || echo "   (Could not comment on PR)"
                  REBASED_COUNT=$((REBASED_COUNT + 1))
                else
                  echo "   âŒ Rebase succeeded but push failed for PR #$PR_NUM"
                  git rebase --abort 2>/dev/null || true
                fi
              else
                # Rebase failed - close PR so Code Agent can recreate fresh
                echo "   âš ï¸ Auto-rebase failed for PR #$PR_NUM - closing for Code Agent to recreate"
                git rebase --abort 2>/dev/null || true

                # Find related issue from PR body (looks for "Fixes #N" or "Relates to #N")
                PR_BODY=$(gh pr view "$PR_NUM" --repo "$GITHUB_REPOSITORY" --json body --jq '.body' 2>/dev/null || echo "")
                RELATED_ISSUE=$(echo "$PR_BODY" | grep -oE '(Fixes|Closes|Relates to|Related to) #[0-9]+' | grep -oE '[0-9]+' | head -1)

                # Close the PR with explanation
                gh pr close "$PR_NUM" --repo "$GITHUB_REPOSITORY" --comment "Closing this PR due to merge conflicts that require intelligent resolution. The related issue still has the ai-ready label, so the Code Agent will automatically create a fresh PR from the current main branch." || echo "   (Could not close PR)"

                # Delete the stale branch
                git push origin --delete "$PR_BRANCH" 2>/dev/null || echo "   (Could not delete branch)"

                # Trigger Code Agent by commenting on the related issue
                if [ -n "$RELATED_ISSUE" ]; then
                  echo "   Triggering Code Agent on issue #$RELATED_ISSUE"
                  gh issue comment "$RELATED_ISSUE" --repo "$GITHUB_REPOSITORY" --body "The previous PR #$PR_NUM was closed due to merge conflicts. Re-triggering Code Agent to create a fresh PR from current main." || echo "   (Could not comment on issue)"
                  # Re-trigger Code Agent by removing and re-adding ai-ready label
                  gh issue edit "$RELATED_ISSUE" --repo "$GITHUB_REPOSITORY" --remove-label "ai-ready" || echo "   (Could not remove ai-ready label)"
                  sleep 2  # Brief pause to ensure label removal is processed
                  gh issue edit "$RELATED_ISSUE" --repo "$GITHUB_REPOSITORY" --add-label "ai-ready" || echo "   (Could not re-add ai-ready label)"
                else
                  echo "   âš ï¸ Could not find related issue to trigger Code Agent"
                fi

                FAILED_COUNT=$((FAILED_COUNT + 1))
              fi

              # Return to main
              git checkout main 2>/dev/null || true
            fi
          done

          echo ""
          echo "ðŸ“Š Auto-rebase summary:"
          echo "   Rebased: $REBASED_COUNT"
          echo "   Failed (need manual): $FAILED_COUNT"
