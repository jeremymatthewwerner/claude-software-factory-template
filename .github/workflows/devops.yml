name: DevOps Agent

on:
  push:
    branches: [main]
  issue_comment:
    types: [created]
  schedule:
    # Run health checks every 5 minutes
    - cron: '*/5 * * * *'
    # Run monitoring audit weekly (Sunday 6am UTC)
    - cron: '0 6 * * 0'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        type: choice
        options:
          - incident-response
          - view-logs
          - restart-service
          - manage-variables
          - provision-infrastructure
          - diagnose
      service:
        description: 'Service name (backend/frontend)'
        type: choice
        options:
          - backend
          - frontend
          - all
        default: 'all'
      severity:
        description: 'Incident severity (for incident-response)'
        type: choice
        options:
          - SEV1
          - SEV2
          - SEV3
        default: 'SEV2'
      description:
        description: 'Description of the issue or action'
        type: string

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

env:
  FAILURE_THRESHOLD: 2

jobs:
  # ===========================================
  # DIAGNOSTIC REQUESTS (triggered by @devops mentions)
  # ===========================================
  diagnostic-request:
    if: |
      github.event_name == 'issue_comment' &&
      !github.event.issue.pull_request &&
      (contains(github.event.comment.body, '@devops') ||
       contains(github.event.comment.body, '@DevOps'))
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Acknowledge request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --body "## ðŸ”§ DevOps Agent Responding

          **Request:** Checking production data...
          **Workflow:** [View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          Please wait while I gather the requested information."

      - name: Install Railway CLI
        run: |
          if curl -fsSL https://railway.app/install.sh | sh; then
            echo "Railway CLI installed"
          else
            echo "Failed to install Railway CLI"
            exit 1
          fi
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Run diagnostic query
        id: diagnostic
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}
          BACKEND_URL: ${{ secrets.PRODUCTION_BACKEND_URL }}
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          echo "Processing diagnostic request..."

          # Check Railway CLI version
          echo "=== Railway CLI Info ===" > /tmp/diagnostic_output.txt
          railway --version >> /tmp/diagnostic_output.txt 2>&1 || echo "Railway CLI not available" >> /tmp/diagnostic_output.txt

          echo "" >> /tmp/diagnostic_output.txt
          echo "=== Service Status ===" >> /tmp/diagnostic_output.txt
          timeout 15 railway status 2>&1 >> /tmp/diagnostic_output.txt || echo "Unable to get status" >> /tmp/diagnostic_output.txt

          # Query Railway API to list services (GraphQL)
          echo "" >> /tmp/diagnostic_output.txt
          echo "=== Railway API - Services ===" >> /tmp/diagnostic_output.txt
          curl -s -X POST https://backboard.railway.app/graphql/v2 \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"query": "query { me { projects { edges { node { id name services { edges { node { id name } } } } } } } }"}' \
            2>&1 >> /tmp/diagnostic_output.txt || echo "API query failed" >> /tmp/diagnostic_output.txt

          # Get backend logs - explicitly specify service AND environment
          echo "" >> /tmp/diagnostic_output.txt
          echo "=== Recent Backend Logs ===" >> /tmp/diagnostic_output.txt
          railway logs --service backend --environment production -n 30 2>&1 >> /tmp/diagnostic_output.txt || echo "Unable to fetch backend logs" >> /tmp/diagnostic_output.txt

          # If the request mentions a specific user, try to find relevant logs
          if echo "$COMMENT_BODY" | grep -qi "user\|username"; then
            echo "" >> /tmp/diagnostic_output.txt
            echo "=== User-Related Logs ===" >> /tmp/diagnostic_output.txt
            (railway logs --service backend -n 100 2>&1 || echo "Unable to fetch logs") | grep -i "user\|auth\|login\|register" | tail -20 >> /tmp/diagnostic_output.txt || echo "No user-related logs found" >> /tmp/diagnostic_output.txt
          fi

          # If the request mentions database or DB
          if echo "$COMMENT_BODY" | grep -qi "database\|db\|postgres"; then
            echo "" >> /tmp/diagnostic_output.txt
            echo "=== Database Connection Status ===" >> /tmp/diagnostic_output.txt
            # Check health endpoint which includes DB status
            if [ -n "$BACKEND_URL" ]; then
              curl -s "$BACKEND_URL/health/ready" 2>&1 >> /tmp/diagnostic_output.txt || echo "Health check unavailable" >> /tmp/diagnostic_output.txt
            else
              echo "PRODUCTION_BACKEND_URL not configured" >> /tmp/diagnostic_output.txt
            fi
          fi

          # Output for next step
          DIAGNOSTIC_OUTPUT=$(cat /tmp/diagnostic_output.txt)
          echo "output<<EOF" >> $GITHUB_OUTPUT
          echo "$DIAGNOSTIC_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post diagnostic results
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DIAGNOSTIC_OUTPUT: ${{ steps.diagnostic.outputs.output }}
        run: |
          # Write comment body to file to avoid shell escaping issues
          cat > /tmp/comment_body.md << 'COMMENT_EOF'
          ## ðŸ”§ DevOps Diagnostic Results

          <details>
          <summary>ðŸ“‹ Diagnostic Output (click to expand)</summary>

          ```
          COMMENT_EOF
          echo "$DIAGNOSTIC_OUTPUT" >> /tmp/comment_body.md
          cat >> /tmp/comment_body.md << 'COMMENT_EOF'
          ```

          </details>

          ---
          **Need more info?** You can request:
          - `@devops check user <username>` - Look for user-related logs
          - `@devops check database` - Check DB connection status
          - `@devops check logs <service>` - Get recent logs for a service

          **Note:** For direct database queries, use `railway connect postgres` locally with your Railway token.
          COMMENT_EOF
          gh issue comment ${{ github.event.issue.number }} --body-file /tmp/comment_body.md

  # ===========================================
  # HEALTH MONITORING (runs every 5 minutes)
  # ===========================================
  smoke-test:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      healthy: ${{ steps.summary.outputs.healthy }}
      failures: ${{ steps.summary.outputs.failures }}

    steps:
      - uses: actions/checkout@v4

      - name: Check backend health endpoint
        id: backend_health
        continue-on-error: true
        run: |
          BACKEND_URL="${{ secrets.PRODUCTION_BACKEND_URL }}"
          if [ -z "$BACKEND_URL" ]; then
            echo "PRODUCTION_BACKEND_URL not set"
            echo "status=skip" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Checking $BACKEND_URL/health..."
          RESPONSE=$(curl -s -w "\n%{http_code}" --max-time 15 "$BACKEND_URL/health" 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)

          echo "status=$HTTP_CODE" >> $GITHUB_OUTPUT
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Backend health check failed: HTTP $HTTP_CODE"
            exit 1
          fi
          echo "Backend health: OK"

      - name: Check frontend loads
        id: frontend
        continue-on-error: true
        run: |
          FRONTEND_URL="${{ secrets.PRODUCTION_FRONTEND_URL }}"
          if [ -z "$FRONTEND_URL" ]; then
            echo "status=skip" >> $GITHUB_OUTPUT
            exit 0
          fi

          RESPONSE=$(curl -s -w "\n%{http_code}" --max-time 15 "$FRONTEND_URL" 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          echo "status=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Frontend check failed: HTTP $HTTP_CODE"
            exit 1
          fi
          echo "Frontend: OK"

      - name: Test auth flow
        id: auth_test
        continue-on-error: true
        run: |
          BACKEND_URL="${{ secrets.PRODUCTION_BACKEND_URL }}"
          if [ -z "$BACKEND_URL" ]; then
            echo "status=skip" >> $GITHUB_OUTPUT
            exit 0
          fi

          TEST_USER="canary_$(date +%s)_$RANDOM"
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$BACKEND_URL/api/auth/register" \
            -H "Content-Type: application/json" \
            -d "{\"username\": \"$TEST_USER\", \"display_name\": \"Canary\", \"password\": \"canarypass123\"}" \
            --max-time 30 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          echo "status=$HTTP_CODE" >> $GITHUB_OUTPUT

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Auth test failed: HTTP $HTTP_CODE"
            exit 1
          fi
          echo "Auth flow: OK"

      - name: Check for stuck PRs and issues
        id: stuck_check
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ” Checking for stuck PRs and issues..."
          STUCK_ITEMS=""
          MERGED_COUNT=0

          # Get list of open PRs
          PR_NUMBERS=$(gh pr list --state open --json number --jq '.[].number' 2>/dev/null || echo "")

          for PR_NUM in $PR_NUMBERS; do
            [ -z "$PR_NUM" ] && continue
            PR_TITLE=$(gh pr view "$PR_NUM" --json title --jq '.title' 2>/dev/null || echo "Unknown")

            # Check if PR CI is passing (all non-skipped checks succeeded)
            CI_STATUS=$(gh pr checks "$PR_NUM" --json state --jq '[.[] | select(.state != "SKIPPED")] | if length == 0 then false else all(.state == "SUCCESS") end' 2>/dev/null || echo "false")

            if [ "$CI_STATUS" = "true" ]; then
              # Check if mergeable
              MERGEABLE=$(gh pr view "$PR_NUM" --json mergeable --jq '.mergeable' 2>/dev/null || echo "UNKNOWN")
              if [ "$MERGEABLE" = "MERGEABLE" ]; then
                echo "âš ï¸ Stuck PR #$PR_NUM: $PR_TITLE - CI passing but not merged"
                STUCK_ITEMS="${STUCK_ITEMS}PR #${PR_NUM}: ${PR_TITLE} (CI passing, ready to merge)\n"

                # Auto-merge if it's been ready
                if gh pr merge "$PR_NUM" --squash --delete-branch 2>/dev/null; then
                  echo "âœ… Auto-merged PR #$PR_NUM"
                  MERGED_COUNT=$((MERGED_COUNT + 1))
                else
                  echo "Could not auto-merge PR #$PR_NUM (may need review or have conflicts)"
                fi
              elif [ "$MERGEABLE" = "CONFLICTING" ]; then
                echo "âš ï¸ PR #$PR_NUM has conflicts: $PR_TITLE"
                STUCK_ITEMS="${STUCK_ITEMS}PR #${PR_NUM}: ${PR_TITLE} (has merge conflicts)\n"
              fi
            fi
          done

          # Check for issues stuck with needs-human label without recent activity
          ONE_HOUR_AGO=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-1H +%Y-%m-%dT%H:%M:%SZ)
          STUCK_ISSUES=$(gh issue list --label "needs-human" --json number,title,updatedAt --jq '.[] | select(.updatedAt < "'"$ONE_HOUR_AGO"'") | "Issue #\(.number): \(.title)"' 2>/dev/null || echo "")
          if [ -n "$STUCK_ISSUES" ]; then
            STUCK_ITEMS="${STUCK_ITEMS}${STUCK_ISSUES}\n"
            echo "âš ï¸ Issues stuck with needs-human label:"
            echo "$STUCK_ISSUES"
          fi

          # Output results
          if [ -n "$STUCK_ITEMS" ]; then
            echo "stuck=true" >> $GITHUB_OUTPUT
            echo "merged=$MERGED_COUNT" >> $GITHUB_OUTPUT
            echo "items<<EOF" >> $GITHUB_OUTPUT
            echo -e "$STUCK_ITEMS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "stuck=false" >> $GITHUB_OUTPUT
            echo "merged=$MERGED_COUNT" >> $GITHUB_OUTPUT
            echo "âœ… No stuck PRs or issues found"
          fi

      - name: Summarize results
        id: summary
        run: |
          FAILURES=""
          HEALTHY="true"

          [ "${{ steps.backend_health.outcome }}" == "failure" ] && FAILURES="${FAILURES}backend," && HEALTHY="false"
          [ "${{ steps.frontend.outcome }}" == "failure" ] && FAILURES="${FAILURES}frontend," && HEALTHY="false"
          [ "${{ steps.auth_test.outcome }}" == "failure" ] && FAILURES="${FAILURES}auth," && HEALTHY="false"

          FAILURES=$(echo "$FAILURES" | sed 's/,$//')
          echo "healthy=$HEALTHY" >> $GITHUB_OUTPUT
          echo "failures=$FAILURES" >> $GITHUB_OUTPUT

  # ===========================================
  # INCIDENT CREATION (when health checks fail)
  # ===========================================
  create-incident:
    needs: smoke-test
    if: needs.smoke-test.outputs.healthy == 'false'
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - name: Install Railway CLI
        continue-on-error: true
        run: |
          # Retry logic for Railway CLI installation (GitHub API can be flaky)
          for attempt in 1 2 3; do
            echo "Railway CLI install attempt $attempt..."
            if curl -fsSL https://railway.app/install.sh | sh; then
              echo "Railway CLI installed successfully"
              break
            fi
            if [ $attempt -lt 3 ]; then
              sleep $((2 ** attempt))
            else
              echo "Warning: Railway CLI installation failed after 3 attempts"
            fi
          done
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Check for existing incident
        id: check_existing
        run: |
          EXISTING=$(gh issue list --label "production-incident" --state open \
            --json number --jq '.[0].number' 2>/dev/null || echo "")
          echo "exists=$( [ -n "$EXISTING" ] && echo true || echo false )" >> $GITHUB_OUTPUT
          echo "issue_number=$EXISTING" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect Railway logs
        id: railway_logs
        continue-on-error: true
        run: |
          # Get last 30 lines of logs from each service (use -n flag to avoid streaming)
          BACKEND_LOGS=$(railway logs --service backend -n 30 2>&1 || echo "Unable to fetch backend logs")
          FRONTEND_LOGS=$(railway logs --service frontend -n 30 2>&1 || echo "Unable to fetch frontend logs")

          echo "backend_logs<<EOF" >> $GITHUB_OUTPUT
          echo "$BACKEND_LOGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "frontend_logs<<EOF" >> $GITHUB_OUTPUT
          echo "$FRONTEND_LOGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}

      - name: Update or create incident
        run: |
          FAILURES="${{ needs.smoke-test.outputs.failures }}"

          if [ "${{ steps.check_existing.outputs.exists }}" == "true" ]; then
            gh issue comment "${{ steps.check_existing.outputs.issue_number }}" --body "## ðŸ”„ Still Failing

          **Time:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Failed:** $FAILURES
          [View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          else
            SEVERITY="SEV2"
            echo "$FAILURES" | grep -q "backend" && SEVERITY="SEV1"

            gh issue create \
              --title "ðŸš¨ Production Incident: $FAILURES failing" \
              --label "bug,priority-high,production-incident,ai-ready" \
              --body "## ðŸš¨ Production Incident

          **Severity:** $SEVERITY
          **Failed Checks:** $FAILURES
          **Detected:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          ### Railway Logs (last 30 lines)

          <details>
          <summary>Backend Logs</summary>

          \`\`\`
          ${{ steps.railway_logs.outputs.backend_logs }}
          \`\`\`
          </details>

          <details>
          <summary>Frontend Logs</summary>

          \`\`\`
          ${{ steps.railway_logs.outputs.frontend_logs }}
          \`\`\`
          </details>

          ### Actions
          - [View workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - Check Railway dashboard for more details
          - Use \`railway logs --service backend\` locally for full logs

          ---
          *Auto-created by DevOps Agent*"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ===========================================
  # MANUAL ACTIONS (workflow_dispatch)
  # ===========================================
  manual-action:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Install Railway CLI
        continue-on-error: true
        run: |
          # Retry logic for Railway CLI installation (GitHub API can be flaky)
          for attempt in 1 2 3; do
            echo "Railway CLI install attempt $attempt..."
            if curl -fsSL https://railway.app/install.sh | sh; then
              echo "Railway CLI installed successfully"
              break
            fi
            if [ $attempt -lt 3 ]; then
              sleep $((2 ** attempt))
            else
              echo "Warning: Railway CLI installation failed after 3 attempts"
            fi
          done
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Link Railway project
        continue-on-error: true
        run: |
          # Railway CLI auto-detects project from RAILWAY_TOKEN in CI mode
          railway status || echo "Railway not linked - some features may be limited"
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}

      - name: Run DevOps Agent
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            Read CLAUDE.md first.

            ## DevOps Action Request

            **Action:** ${{ github.event.inputs.action }}
            **Service:** ${{ github.event.inputs.service }}
            **Severity:** ${{ github.event.inputs.severity }}
            **Description:** ${{ github.event.inputs.description }}

            ## Available Railway CLI Commands

            You have access to the Railway CLI. Key commands:

            ### Viewing Logs
            Use the `-n` flag to limit output and avoid indefinite streaming:
            ```bash
            railway logs --service backend -n 50     # Get last 50 lines from backend
            railway logs --service frontend -n 50    # Get last 50 lines from frontend
            railway logs -n 100                      # All services, more lines
            railway logs --build                     # Build logs
            ```

            ### Service Management
            ```bash
            railway status                         # Project status
            railway redeploy                       # Redeploy latest
            railway down                           # Remove last deployment (CAREFUL!)
            ```

            ### Environment Variables
            ```bash
            railway variables                      # List all variables
            railway variables --set "KEY=value"    # Set a variable
            railway variables --service backend    # Service-specific vars
            ```

            ### Database Access
            ```bash
            railway connect postgres               # Open psql shell
            ```

            ### Provisioning New Infrastructure
            ```bash
            railway add --database postgres        # Add PostgreSQL
            railway add --database redis           # Add Redis
            railway add --service myservice        # Add empty service
            ```

            ## Action-Specific Instructions

            ### For "incident-response":
            1. Check health endpoints with curl
            2. Get Railway logs: `railway logs --service backend -n 100`
            3. Look for errors, exceptions, connection issues
            4. Check recent deployments: `gh run list --limit 10`
            5. If code issue: create a fix PR
            6. If infra issue: check Railway dashboard, restart if needed
            7. Document findings in issue comment
            8. Escalate SEV1 to @jeremymatthewwerner

            ### For "view-logs":
            1. Run `railway logs --service ${{ github.event.inputs.service }} -n 100`
            2. Look for patterns: errors, warnings, slow queries
            3. Summarize findings in a new issue or comment

            ### For "restart-service":
            1. First check current status: `railway status`
            2. Get current logs to document state before restart
            3. Run `railway redeploy` (this deploys the latest successful build)
            4. Wait 60 seconds, then verify health endpoints
            5. Document the restart in an issue comment

            ### For "manage-variables":
            1. List current variables: `railway variables`
            2. If adding/changing: `railway variables --set "KEY=value"`
            3. Document changes (but never log sensitive values!)
            4. Note: Variable changes may require redeploy

            ### For "provision-infrastructure":
            1. ONLY provision if explicitly requested in description
            2. Available: `railway add --database postgres|mysql|redis|mongo`
            3. Document what was provisioned
            4. Update any necessary environment variables
            5. Create issue to track the new resource

            ### For "diagnose":
            1. Check health endpoints using the URLs from environment variables:
               - Backend: $PRODUCTION_BACKEND_URL/health
               - Frontend: $PRODUCTION_FRONTEND_URL
               **IMPORTANT:** Do NOT try to reach custom domains (e.g., example.com) directly -
               GitHub Actions runners have network restrictions that cause false DNS failures.
               Always use the Railway URLs from the environment variables.
            2. Get logs from all services
            3. Check recent CI runs
            4. Look at recent commits
            5. Check Railway status
            6. Compile a diagnostic report

            ## Important Rules

            - NEVER expose secrets or tokens in logs/comments
            - Document all actions taken in GitHub issues
            - For destructive actions (railway down), confirm twice and document
            - Escalate to human for: security issues, data loss risk, unclear situations
            - After any fix, verify health endpoints are working

          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_args: |
            --model claude-opus-4-5-20251101
            --dangerously-skip-permissions
            --allowedTools "Bash(railway:*),Bash(gh:*),Bash(curl:*),Bash(git:*),Read,Glob,Grep"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}
          PRODUCTION_BACKEND_URL: ${{ secrets.PRODUCTION_BACKEND_URL }}
          PRODUCTION_FRONTEND_URL: ${{ secrets.PRODUCTION_FRONTEND_URL }}

  # ===========================================
  # WEEKLY MONITORING AUDIT (ensures completeness)
  # ===========================================
  monitoring-audit:
    if: github.event_name == 'schedule' && github.event.schedule == '0 6 * * 0'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Install Railway CLI
        continue-on-error: true
        run: |
          # Retry logic for Railway CLI installation (GitHub API can be flaky)
          for attempt in 1 2 3; do
            echo "Railway CLI install attempt $attempt..."
            if curl -fsSL https://railway.app/install.sh | sh; then
              echo "Railway CLI installed successfully"
              break
            fi
            if [ $attempt -lt 3 ]; then
              sleep $((2 ** attempt))
            else
              echo "Warning: Railway CLI installation failed after 3 attempts"
            fi
          done
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Run Monitoring Audit
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            Read CLAUDE.md first.

            ## Weekly Monitoring & Dashboard Audit

            Your task is to audit the monitoring and observability setup and ensure it's complete.

            ### Audit Checklist

            1. **Health Endpoints**
               - Check all services have /health endpoints responding
               - Verify health check frequency is appropriate (every 5 min)
               - Ensure health checks cover critical dependencies (DB, cache, etc.)

            2. **Logging**
               - Run `railway logs --service backend -n 50` and `railway logs --service frontend -n 50`
               - Use the `-n` flag to limit output and avoid indefinite streaming
               - Check logs have proper structure (timestamps, levels, context)
               - Look for any recurring errors that need attention

            3. **Alerting**
               - Review existing GitHub issues labeled `production-incident`
               - Check if incidents are being created when health checks fail
               - Verify escalation path is documented in CLAUDE.md

            4. **Dashboard Completeness**
               - Check Railway dashboard has all services visible
               - Verify environment variables are properly set
               - Review recent deployments for any failures

            5. **Documentation**
               - Ensure CLAUDE.md has accurate runbook for common issues
               - Verify DevOps section documents all available actions
               - Check secrets list is complete

            ### Actions to Take

            - If monitoring gaps found: Create GitHub issue with `monitoring` label
            - If dashboard incomplete: Document what's missing in an issue
            - If alerts missing: Update devops.yml or create issue
            - If everything OK: Create brief status comment on tracking issue (if exists)

            ### Output

            Create a GitHub issue titled "ðŸ“Š Weekly Monitoring Audit - [DATE]" with:
            - Summary of audit findings
            - List of any gaps or issues found
            - Recommendations for improvements
            - Status: âœ… Complete / âš ï¸ Needs Attention / âŒ Critical Issues

          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_args: |
            --model claude-sonnet-4-20250514
            --dangerously-skip-permissions
            --allowedTools "Bash(railway:*),Bash(gh:*),Bash(curl:*),Read,Glob,Grep"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN_SW_FACTORY }}

  # ===========================================
  # AUTO-REBASE (triggered on push to main)
  # ===========================================
  auto-rebase:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Auto-rebase conflicting PRs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ”„ Checking for PRs with merge conflicts after push to main..."
          echo "   Repository: $GITHUB_REPOSITORY"

          # Wait for GitHub to compute mergeable status after push
          echo "   Waiting 10s for GitHub to update PR status..."
          sleep 10

          # Get all open PR numbers
          PR_NUMBERS=$(gh pr list --repo "$GITHUB_REPOSITORY" --state open --json number --jq '.[].number' 2>/dev/null)

          if [ -z "$PR_NUMBERS" ]; then
            echo "âœ… No open PRs to check"
            exit 0
          fi

          echo "   Open PRs: $PR_NUMBERS"

          REBASED_COUNT=0
          FAILED_COUNT=0

          for PR_NUM in $PR_NUMBERS; do
            [ -z "$PR_NUM" ] && continue

            # Query each PR individually for accurate mergeable status
            PR_INFO=$(gh pr view "$PR_NUM" --repo "$GITHUB_REPOSITORY" --json title,headRefName,mergeable 2>/dev/null)
            PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
            PR_BRANCH=$(echo "$PR_INFO" | jq -r '.headRefName')
            MERGEABLE=$(echo "$PR_INFO" | jq -r '.mergeable')

            echo "   Checking PR #$PR_NUM: mergeable=$MERGEABLE"

            # If still UNKNOWN, wait and retry once
            if [ "$MERGEABLE" = "UNKNOWN" ]; then
              echo "   Status UNKNOWN, waiting 5s and retrying..."
              sleep 5
              MERGEABLE=$(gh pr view "$PR_NUM" --repo "$GITHUB_REPOSITORY" --json mergeable --jq '.mergeable' 2>/dev/null)
              echo "   Retry result: mergeable=$MERGEABLE"
            fi

            # Check if PR has conflicts
            if [ "$MERGEABLE" = "CONFLICTING" ]; then
              echo "ðŸ”§ PR #$PR_NUM has conflicts: $PR_TITLE"
              echo "   Branch: $PR_BRANCH"

              # Fetch the PR branch
              if ! git fetch origin "$PR_BRANCH" 2>&1; then
                echo "   âŒ Could not fetch branch $PR_BRANCH"
                continue
              fi

              # Try to rebase
              if ! git checkout "$PR_BRANCH" 2>&1; then
                echo "   âŒ Could not checkout branch $PR_BRANCH"
                continue
              fi

              if git rebase origin/main 2>&1; then
                # Rebase succeeded - force push
                if git push --force-with-lease origin "$PR_BRANCH" 2>&1; then
                  echo "   âœ… Successfully rebased and pushed PR #$PR_NUM"
                  gh pr comment "$PR_NUM" --repo "$GITHUB_REPOSITORY" --body "Auto-rebased this PR onto main to resolve merge conflicts." || echo "   (Could not comment on PR)"
                  REBASED_COUNT=$((REBASED_COUNT + 1))
                else
                  echo "   âŒ Rebase succeeded but push failed for PR #$PR_NUM"
                  git rebase --abort 2>/dev/null || true
                fi
              else
                # Rebase failed - close PR so Code Agent can recreate fresh
                echo "   âš ï¸ Auto-rebase failed for PR #$PR_NUM - closing for Code Agent to recreate"
                git rebase --abort 2>/dev/null || true

                # Find related issue from PR body (looks for "Fixes #N" or "Relates to #N")
                PR_BODY=$(gh pr view "$PR_NUM" --repo "$GITHUB_REPOSITORY" --json body --jq '.body' 2>/dev/null || echo "")
                RELATED_ISSUE=$(echo "$PR_BODY" | grep -oE '(Fixes|Closes|Relates to|Related to) #[0-9]+' | grep -oE '[0-9]+' | head -1)

                # Close the PR with explanation
                gh pr close "$PR_NUM" --repo "$GITHUB_REPOSITORY" --comment "Closing this PR due to merge conflicts that require intelligent resolution. The related issue still has the ai-ready label, so the Code Agent will automatically create a fresh PR from the current main branch." || echo "   (Could not close PR)"

                # Delete the stale branch
                git push origin --delete "$PR_BRANCH" 2>/dev/null || echo "   (Could not delete branch)"

                # Trigger Code Agent by commenting on the related issue
                if [ -n "$RELATED_ISSUE" ]; then
                  echo "   Triggering Code Agent on issue #$RELATED_ISSUE"
                  gh issue comment "$RELATED_ISSUE" --repo "$GITHUB_REPOSITORY" --body "The previous PR was closed due to merge conflicts. Code Agent: please create a fresh PR from current main." || echo "   (Could not comment on issue)"
                else
                  echo "   âš ï¸ Could not find related issue to trigger Code Agent"
                fi

                FAILED_COUNT=$((FAILED_COUNT + 1))
              fi

              # Return to main
              git checkout main 2>/dev/null || true
            fi
          done

          echo ""
          echo "ðŸ“Š Auto-rebase summary:"
          echo "   Rebased: $REBASED_COUNT"
          echo "   Failed (need manual): $FAILED_COUNT"
