name: Factory Manager

on:
  schedule:
    - cron: '*/5 * * * *'   # Every 5 minutes for health checks
    - cron: '0 6 * * 1'     # Weekly report on Monday 6am UTC
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - full-health-check
          - trigger-verification
          - weekly-report
          - diagnose-issue
      issue_number:
        description: 'Issue number (for diagnose-issue action)'
        required: false
        type: number
  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read

# Only one Factory Manager run at a time
concurrency:
  group: factory-manager
  cancel-in-progress: false

jobs:
  # ===========================================
  # HEALTH CHECK (every 5 minutes)
  # ===========================================
  health-check:
    if: |
      (github.event_name == 'schedule' && github.event.schedule != '0 6 * * 1') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'full-health-check')
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4

      - name: Check for stuck issues
        id: stuck
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Checking for stuck issues..."

          # Get current time minus 30 minutes (in ISO format)
          THRESHOLD=$(date -u -d '30 minutes ago' '+%Y-%m-%dT%H:%M:%SZ')

          # Find issues that:
          # 1. Have bug OR enhancement label (triaged)
          # 2. Have a @code mention in comments (agent was triggered)
          # 3. Don't have factory-meta or needs-human labels
          # 4. Don't have status:bot-working (agent not currently active)
          # 5. Haven't been updated in 30 min
          # 6. Are open

          STUCK_ISSUES=$(gh issue list \
            --repo ${{ github.repository }} \
            --state open \
            --json number,title,labels,updatedAt,comments \
            --jq --arg threshold "$THRESHOLD" '
              [.[] | select(
                (.labels | map(.name) | (contains(["bug"]) or contains(["enhancement"]))) and
                (.labels | map(.name) | contains(["factory-meta"]) | not) and
                (.labels | map(.name) | contains(["needs-human"]) | not) and
                (.labels | map(.name) | contains(["status:bot-working"]) | not) and
                (.comments | map(.body) | join(" ") | test("@code|@Code|@claude|@Claude")) and
                (.updatedAt < $threshold)
              ) | {number, title, updatedAt}]
            ' 2>/dev/null || echo "[]")

          STUCK_COUNT=$(echo "$STUCK_ISSUES" | jq 'length')
          echo "Found $STUCK_COUNT stuck issues"

          if [ "$STUCK_COUNT" -gt 0 ]; then
            echo "has_stuck=true" >> $GITHUB_OUTPUT
            echo "stuck_issues<<EOF" >> $GITHUB_OUTPUT
            echo "$STUCK_ISSUES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_stuck=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for long-running bot work
        id: longrunning
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Checking for issues with bot-working for >60 min..."

          THRESHOLD=$(date -u -d '60 minutes ago' '+%Y-%m-%dT%H:%M:%SZ')

          LONGRUNNING=$(gh issue list \
            --repo ${{ github.repository }} \
            --label "status:bot-working" \
            --state open \
            --json number,title,updatedAt \
            --jq --arg threshold "$THRESHOLD" '
              [.[] | select(.updatedAt < $threshold)]
            ' 2>/dev/null || echo "[]")

          COUNT=$(echo "$LONGRUNNING" | jq 'length')
          echo "Found $COUNT long-running issues"

          if [ "$COUNT" -gt 0 ]; then
            echo "has_longrunning=true" >> $GITHUB_OUTPUT
            echo "longrunning_issues<<EOF" >> $GITHUB_OUTPUT
            echo "$LONGRUNNING" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_longrunning=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for failed workflows
        id: failed
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Checking for recent failed workflows..."

          # Get failed runs in last 2 hours
          FAILED_RUNS=$(gh run list \
            --repo ${{ github.repository }} \
            --status failure \
            --limit 20 \
            --json databaseId,name,conclusion,headBranch,createdAt \
            --jq '
              [.[] | select(
                (.createdAt | fromdateiso8601) > (now - 7200) and
                (.name != "Factory Manager")
              )]
            ' 2>/dev/null || echo "[]")

          COUNT=$(echo "$FAILED_RUNS" | jq 'length')
          echo "Found $COUNT recent failed runs"

          if [ "$COUNT" -gt 0 ]; then
            echo "has_failed=true" >> $GITHUB_OUTPUT
            echo "failed_runs<<EOF" >> $GITHUB_OUTPUT
            echo "$FAILED_RUNS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for stuck PRs
        id: stuck_prs
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Checking for stuck PRs..."

          # Get current time minus 30 minutes
          THRESHOLD=$(date -u -d '30 minutes ago' '+%Y-%m-%dT%H:%M:%SZ')

          # Find open PRs with failing CI or no activity
          STUCK_PRS=$(gh pr list \
            --repo ${{ github.repository }} \
            --state open \
            --json number,title,headRefName,updatedAt,statusCheckRollup,author \
            --jq --arg threshold "$THRESHOLD" '
              [.[] | select(
                (.updatedAt < $threshold) and
                (
                  (.statusCheckRollup | length > 0) and
                  (.statusCheckRollup | any(.conclusion == "FAILURE"))
                )
              ) | {number, title, branch: .headRefName, author: .author.login, updatedAt}]
            ' 2>/dev/null || echo "[]")

          COUNT=$(echo "$STUCK_PRS" | jq 'length')
          echo "Found $COUNT stuck PRs with failing CI"

          if [ "$COUNT" -gt 0 ]; then
            echo "has_stuck_prs=true" >> $GITHUB_OUTPUT
            echo "stuck_prs<<EOF" >> $GITHUB_OUTPUT
            echo "$STUCK_PRS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_stuck_prs=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for long-running CI
        id: longrunning_ci
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Checking for PRs with long-running CI (>10 min)..."

          # Check in_progress CI runs and look at specific E2E job duration
          # Normal E2E tests take ~6-7 min, so 10+ min is suspicious
          LONGRUNNING_RUNS="[]"

          # Get all in_progress CI/CD runs
          IN_PROGRESS_RUNS=$(gh run list \
            --repo ${{ github.repository }} \
            --status in_progress \
            --limit 20 \
            --json databaseId,name,headBranch,createdAt \
            --jq '[.[] | select(.name == "CI/CD")]' 2>/dev/null || echo "[]")

          # For each run, check if E2E Tests job has been running >10 min
          THRESHOLD_SECS=600  # 10 minutes
          NOW_SECS=$(date +%s)

          STUCK_RUNS=$(echo "$IN_PROGRESS_RUNS" | jq -c '.[]' | while read -r run; do
            RUN_ID=$(echo "$run" | jq -r '.databaseId')
            BRANCH=$(echo "$run" | jq -r '.headBranch')

            # Get E2E Tests job status
            E2E_JOB=$(gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/jobs \
              --jq '.jobs[] | select(.name == "E2E Tests") | {status, started_at, steps: [.steps[] | select(.name == "Run E2E tests") | {status, started_at}]}' 2>/dev/null || echo "{}")

            E2E_STATUS=$(echo "$E2E_JOB" | jq -r '.status // "unknown"')
            E2E_STEP_STARTED=$(echo "$E2E_JOB" | jq -r '.steps[0].started_at // ""')
            E2E_STEP_STATUS=$(echo "$E2E_JOB" | jq -r '.steps[0].status // "unknown"')

            # Only check if E2E step is actually in_progress
            if [ "$E2E_STEP_STATUS" = "in_progress" ] && [ -n "$E2E_STEP_STARTED" ]; then
              STEP_START_SECS=$(date -d "$E2E_STEP_STARTED" +%s 2>/dev/null || echo 0)
              if [ "$STEP_START_SECS" -gt 0 ]; then
                RUNNING_SECS=$((NOW_SECS - STEP_START_SECS))
                if [ "$RUNNING_SECS" -gt "$THRESHOLD_SECS" ]; then
                  RUNNING_MINS=$((RUNNING_SECS / 60))
                  echo "{\"runId\": $RUN_ID, \"branch\": \"$BRANCH\", \"runningMins\": $RUNNING_MINS}"
                fi
              fi
            fi
          done | jq -s '.' 2>/dev/null || echo "[]")

          LONGRUNNING_RUNS="$STUCK_RUNS"

          COUNT=$(echo "$LONGRUNNING_RUNS" | jq 'length')
          echo "Found $COUNT long-running CI runs"

          if [ "$COUNT" -gt 0 ]; then
            echo "has_longrunning_ci=true" >> $GITHUB_OUTPUT
            echo "longrunning_runs<<EOF" >> $GITHUB_OUTPUT
            echo "$LONGRUNNING_RUNS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_longrunning_ci=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for untriggered issues
        id: untriggered
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Checking for triaged issues with no @code mention..."

          THRESHOLD=$(date -u -d '15 minutes ago' '+%Y-%m-%dT%H:%M:%SZ')

          # Find issues that have been triaged (bug or enhancement label) but no @code mention
          # This is @mention based - labels are for categorization only
          UNTRIGGERED=$(gh issue list \
            --repo ${{ github.repository }} \
            --state open \
            --json number,title,labels,createdAt,comments \
            --jq --arg threshold "$THRESHOLD" '
              [.[] | select(
                (.createdAt < $threshold) and
                (.labels | map(.name) | (contains(["bug"]) or contains(["enhancement"]))) and
                (.labels | map(.name) | contains(["factory-meta"]) | not) and
                (.labels | map(.name) | contains(["needs-human"]) | not) and
                (.labels | map(.name) | contains(["status:bot-working"]) | not) and
                ((.comments | length == 0) or (.comments | map(.body) | join(" ") | test("@code|@Code|@claude|@Claude") | not))
              ) | {number, title}]
            ' 2>/dev/null || echo "[]")

          COUNT=$(echo "$UNTRIGGERED" | jq 'length')
          echo "Found $COUNT triaged issues needing Code Agent trigger"

          if [ "$COUNT" -gt 0 ]; then
            echo "has_untriggered=true" >> $GITHUB_OUTPUT
            echo "untriggered_issues<<EOF" >> $GITHUB_OUTPUT
            echo "$UNTRIGGERED" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_untriggered=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for unlabeled issues (failed triage)
        id: unlabeled
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Checking for unlabeled issues (triage may have failed)..."

          THRESHOLD=$(date -u -d '15 minutes ago' '+%Y-%m-%dT%H:%M:%SZ')

          # Find issues older than 15 min with NO labels at all (triage probably failed)
          UNLABELED=$(gh issue list \
            --repo ${{ github.repository }} \
            --state open \
            --json number,title,labels,createdAt \
            --jq --arg threshold "$THRESHOLD" '
              [.[] | select(
                (.createdAt < $threshold) and
                ((.labels | length) == 0)
              ) | {number, title, createdAt}]
            ' 2>/dev/null || echo "[]")

          COUNT=$(echo "$UNLABELED" | jq 'length')
          echo "Found $COUNT unlabeled issues (possible failed triage)"

          if [ "$COUNT" -gt 0 ]; then
            echo "has_unlabeled=true" >> $GITHUB_OUTPUT
            echo "unlabeled_issues<<EOF" >> $GITHUB_OUTPUT
            echo "$UNLABELED" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_unlabeled=false" >> $GITHUB_OUTPUT
          fi

      - name: Re-trigger stuck issues
        if: steps.stuck.outputs.has_stuck == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          STUCK_ISSUES: ${{ steps.stuck.outputs.stuck_issues }}
        run: |
          echo "Re-triggering stuck issues..."

          # Track how many we've re-triggered (max 5 per cycle to avoid spam)
          RETRIGGER_COUNT=0
          MAX_RETRIGGERS=5

          # Use process substitution to avoid subshell variable scope issue
          while read -r issue; do
            [ "$RETRIGGER_COUNT" -ge "$MAX_RETRIGGERS" ] && break

            ISSUE_NUM=$(echo "$issue" | jq -r '.number')
            ISSUE_TITLE=$(echo "$issue" | jq -r '.title')

            echo "Checking if issue #$ISSUE_NUM was already re-triggered recently..."

            # Check if Factory Manager already commented in last hour
            RECENT_FM_COMMENT=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUM/comments \
              --jq '[.[] | select(
                (.body | contains("[Factory Manager]")) and
                ((.created_at | fromdateiso8601) > (now - 3600))
              )] | length' 2>/dev/null || echo "0")

            if [ "$RECENT_FM_COMMENT" -gt 0 ]; then
              echo "  Issue #$ISSUE_NUM already re-triggered recently, skipping"
              continue
            fi

            echo "  Re-triggering issue #$ISSUE_NUM: $ISSUE_TITLE"

            COMMENT_BODY="@code [Factory Manager] This issue appears stuck (no agent activity in 30+ min). Please investigate and continue work.

            _Automated re-trigger by Factory Manager. If this keeps happening, there may be a systemic issue._"
            gh issue comment "$ISSUE_NUM" \
              --repo ${{ github.repository }} \
              --body "$COMMENT_BODY"

            RETRIGGER_COUNT=$((RETRIGGER_COUNT + 1))
          done < <(echo "$STUCK_ISSUES" | jq -c '.[]')

          echo "Re-triggered $RETRIGGER_COUNT issues"

      - name: Handle long-running issues
        if: steps.longrunning.outputs.has_longrunning == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          LONGRUNNING_ISSUES: ${{ steps.longrunning.outputs.longrunning_issues }}
        run: |
          echo "Checking long-running issues..."

          echo "$LONGRUNNING_ISSUES" | jq -c '.[]' | head -3 | while read -r issue; do
            ISSUE_NUM=$(echo "$issue" | jq -r '.number')
            ISSUE_TITLE=$(echo "$issue" | jq -r '.title')

            echo "Issue #$ISSUE_NUM has had bot-working for >60 min: $ISSUE_TITLE"

            # Check for recent workflow activity
            RECENT_RUNS=$(gh run list \
              --repo ${{ github.repository }} \
              --workflow=bug-fix.yml \
              --limit 5 \
              --json databaseId,status,conclusion \
              --jq '[.[] | select(.status == "in_progress" or .status == "queued")] | length' 2>/dev/null || echo "0")

            if [ "$RECENT_RUNS" -gt 0 ]; then
              echo "  Workflow is still running, no action needed"
            else
              echo "  No active workflow, posting status update"
              LONGRUN_BODY="[Factory Manager] This issue has had status:bot-working for over 60 minutes but no active workflow is running.

              Possible causes:
              1. Workflow timed out without cleanup
              2. Workflow failed without status update
              3. Network/infrastructure issue

              Recommended action: Check workflow runs for this issue.

              @your-github-username - This may need manual investigation."
              gh issue comment "$ISSUE_NUM" \
                --repo ${{ github.repository }} \
                --body "$LONGRUN_BODY"

              # Remove bot-working, add awaiting-human
              gh issue edit "$ISSUE_NUM" \
                --repo ${{ github.repository }} \
                --remove-label "status:bot-working" \
                --add-label "status:awaiting-human" 2>/dev/null || true
            fi
          done

      - name: Handle stuck PRs
        if: steps.stuck_prs.outputs.has_stuck_prs == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          STUCK_PRS: ${{ steps.stuck_prs.outputs.stuck_prs }}
        run: |
          echo "Handling stuck PRs with failing CI..."

          HANDLED_COUNT=0
          MAX_HANDLE=3

          echo "$STUCK_PRS" | jq -c '.[]' | head -$MAX_HANDLE | while read -r pr; do
            PR_NUM=$(echo "$pr" | jq -r '.number')
            PR_TITLE=$(echo "$pr" | jq -r '.title')
            PR_BRANCH=$(echo "$pr" | jq -r '.branch')
            PR_AUTHOR=$(echo "$pr" | jq -r '.author')

            echo "Checking PR #$PR_NUM: $PR_TITLE"

            # Check if Factory Manager already commented recently
            RECENT_FM_COMMENT=$(gh api repos/${{ github.repository }}/pulls/$PR_NUM/comments \
              --jq '[.[] | select(
                (.body | contains("[Factory Manager]")) and
                ((.created_at | fromdateiso8601) > (now - 3600))
              )] | length' 2>/dev/null || echo "0")

            if [ "$RECENT_FM_COMMENT" -gt 0 ]; then
              echo "  Already commented recently, skipping"
              continue
            fi

            # Get the failed checks
            FAILED_CHECKS=$(gh pr view "$PR_NUM" --repo ${{ github.repository }} \
              --json statusCheckRollup \
              --jq '[.statusCheckRollup[] | select(.conclusion == "FAILURE") | .name] | join(", ")' 2>/dev/null || echo "unknown")

            # Find related issue from branch name (claude/fix-XXX-*)
            RELATED_ISSUE=""
            if [[ "$PR_BRANCH" =~ fix-([0-9]+) ]] || [[ "$PR_BRANCH" =~ feat-([0-9]+) ]]; then
              RELATED_ISSUE="${BASH_REMATCH[1]}"
            fi

            # Post comment on PR
            COMMENT_FILE=$(mktemp)
            {
              echo "## [Factory Manager] PR Stuck with Failing CI"
              echo ""
              echo "This PR has had failing CI for over 30 minutes."
              echo ""
              echo "**Failed checks:** $FAILED_CHECKS"
              echo ""
              echo "**Recommended actions:**"
              echo "1. Review the CI logs: [View workflow runs](https://github.com/${{ github.repository }}/actions?query=branch%3A$PR_BRANCH)"
              echo "2. Fix the failing tests/checks"
              echo "3. Push updated code"
              echo ""
              echo "_If this PR was created by an agent, consider re-triggering with \\\`@code please fix the CI failures\\\`_"
            } > "$COMMENT_FILE"

            gh pr comment "$PR_NUM" --repo ${{ github.repository }} --body-file "$COMMENT_FILE"
            rm -f "$COMMENT_FILE"

            # If there's a related issue, also notify there
            if [ -n "$RELATED_ISSUE" ]; then
              ISSUE_FILE=$(mktemp)
              {
                echo "[Factory Manager] PR #$PR_NUM has been stuck with failing CI for over 30 minutes."
                echo ""
                echo "Failed checks: $FAILED_CHECKS"
                echo ""
                echo "@code please investigate and fix the CI failures in PR #$PR_NUM."
              } > "$ISSUE_FILE"
              gh issue comment "$RELATED_ISSUE" --repo ${{ github.repository }} --body-file "$ISSUE_FILE" 2>/dev/null || true
              rm -f "$ISSUE_FILE"
            fi

            HANDLED_COUNT=$((HANDLED_COUNT + 1))
          done

          echo "Handled $HANDLED_COUNT stuck PRs"

      - name: Handle long-running CI
        if: steps.longrunning_ci.outputs.has_longrunning_ci == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          LONGRUNNING_RUNS: ${{ steps.longrunning_ci.outputs.longrunning_runs }}
        run: |
          echo "Checking long-running CI runs..."

          echo "$LONGRUNNING_RUNS" | jq -c '.[]' | head -3 | while read -r run; do
            RUN_ID=$(echo "$run" | jq -r '.runId')
            RUN_BRANCH=$(echo "$run" | jq -r '.branch')

            echo "Checking run $RUN_ID on branch $RUN_BRANCH..."

            # Get the specific job that's taking long
            SLOW_JOBS=$(gh api repos/${{ github.repository }}/actions/runs/$RUN_ID/jobs \
              --jq '[.jobs[] | select(.status == "in_progress") | .name] | join(", ")' 2>/dev/null || echo "unknown")

            # Find PR number for this branch
            PR_NUM=$(gh pr list --repo ${{ github.repository }} \
              --head "$RUN_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")

            if [ -z "$PR_NUM" ]; then
              echo "  No PR found for branch $RUN_BRANCH, skipping"
              continue
            fi

            # Check if we already commented about cancelling
            RECENT_FM_COMMENT=$(gh api repos/${{ github.repository }}/issues/$PR_NUM/comments \
              --jq '[.[] | select(
                (.body | contains("[Factory Manager]")) and
                (.body | contains("cancelled")) and
                ((.created_at | fromdateiso8601) > (now - 3600))
              )] | length' 2>/dev/null || echo "0")

            if [ "$RECENT_FM_COMMENT" -gt 0 ]; then
              echo "  Already handled this run, skipping"
              continue
            fi

            # Extract issue number from branch
            RELATED_ISSUE=""
            if [[ "$RUN_BRANCH" =~ -([0-9]+)$ ]] || [[ "$RUN_BRANCH" =~ /([0-9]+)- ]]; then
              RELATED_ISSUE="${BASH_REMATCH[1]}"
            fi

            # Get running time from the run data
            RUNNING_MINS=$(echo "$run" | jq -r '.runningMins // "10+"')

            # CANCEL the stuck run
            echo "  Cancelling stuck run $RUN_ID (running $RUNNING_MINS min)..."
            if gh run cancel "$RUN_ID" --repo ${{ github.repository }} 2>/dev/null; then
              CANCEL_STATUS="cancelled"
            else
              CANCEL_STATUS="cancel failed"
            fi

            # Post notification on PR
            COMMENT_FILE=$(mktemp)
            {
              echo "## [Factory Manager] Stuck CI Cancelled"
              echo ""
              echo "The E2E Tests step was running for **$RUNNING_MINS minutes** (normal: ~6-7 min) and appeared stuck."
              echo ""
              echo "**Action taken:** Run $CANCEL_STATUS"
              echo "**Slow job(s):** $SLOW_JOBS"
              echo "**Run:** [View logs](https://github.com/${{ github.repository }}/actions/runs/$RUN_ID)"
              echo ""
              echo "**Next steps:**"
              echo "1. Check if there's a test hanging or infinite loop"
              echo "2. Push a fix and CI will re-run automatically"
              echo "3. Or manually re-run: \`gh run rerun $RUN_ID\`"
            } > "$COMMENT_FILE"

            gh pr comment "$PR_NUM" --repo ${{ github.repository }} --body-file "$COMMENT_FILE"
            rm -f "$COMMENT_FILE"

            # Trigger Code Agent to investigate and fix
            if [ -n "$RELATED_ISSUE" ]; then
              ISSUE_FILE=$(mktemp)
              {
                echo "[Factory Manager] PR #$PR_NUM E2E tests were stuck ($RUNNING_MINS min) and have been cancelled."
                echo ""
                echo "**Slow job(s):** $SLOW_JOBS"
                echo "**Run logs:** https://github.com/${{ github.repository }}/actions/runs/$RUN_ID"
                echo ""
                echo "@code Please investigate why E2E tests got stuck and fix it. Check:"
                echo "1. The test logs for hanging tests or infinite loops"
                echo "2. Backend logs for errors or slow responses"
                echo "3. Any recent changes that might cause timeouts"
              } > "$ISSUE_FILE"
              gh issue comment "$RELATED_ISSUE" --repo ${{ github.repository }} --body-file "$ISSUE_FILE" 2>/dev/null || true
              rm -f "$ISSUE_FILE"
            else
              # No related issue - create one and then comment to trigger Code Agent
              # (Code Agent triggers on comments, not issue body @mentions)
              ISSUE_FILE=$(mktemp)
              {
                echo "## E2E Tests Stuck and Cancelled"
                echo ""
                echo "PR #$PR_NUM had E2E tests running for $RUNNING_MINS min (normal: ~6-7 min)."
                echo "The run was automatically cancelled by Factory Manager."
                echo ""
                echo "**Branch:** $RUN_BRANCH"
                echo "**Slow job(s):** $SLOW_JOBS"
                echo "**Run logs:** https://github.com/${{ github.repository }}/actions/runs/$RUN_ID"
              } > "$ISSUE_FILE"
              NEW_ISSUE_URL=$(gh issue create --repo ${{ github.repository }} \
                --title "E2E tests stuck on PR #$PR_NUM" \
                --label "bug,priority-high,ci-failure" \
                --body-file "$ISSUE_FILE" 2>/dev/null || echo "")
              rm -f "$ISSUE_FILE"

              # Post comment to trigger Code Agent
              if [ -n "$NEW_ISSUE_URL" ]; then
                NEW_ISSUE_NUM=$(echo "$NEW_ISSUE_URL" | grep -oE '[0-9]+$')
                if [ -n "$NEW_ISSUE_NUM" ]; then
                  gh issue comment "$NEW_ISSUE_NUM" --repo ${{ github.repository }} \
                    --body "@code Please investigate why E2E tests got stuck and fix it." 2>/dev/null || true
                fi
              fi
            fi
          done

      - name: Handle failed workflows (create issues)
        if: steps.failed.outputs.has_failed == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          FAILED_RUNS: ${{ steps.failed.outputs.failed_runs }}
        run: |
          echo "Checking if failed workflows need issues..."

          # Only create issues for main branch failures that don't already have issues
          echo "$FAILED_RUNS" | jq -c '.[] | select(.headBranch == "main")' | head -3 | while read -r run; do
            RUN_ID=$(echo "$run" | jq -r '.databaseId')
            RUN_NAME=$(echo "$run" | jq -r '.name')

            echo "Checking failed run $RUN_ID ($RUN_NAME) on main..."

            # Check if an issue already exists for this run ID
            # NOTE: Don't use --search (has indexing delays), check body content directly
            EXISTING_ISSUE=$(gh issue list \
              --repo ${{ github.repository }} \
              --label "ci-failure" \
              --state all \
              --limit 50 \
              --json number,body \
              --jq --arg run_id "$RUN_ID" '[.[] | select(.body | contains($run_id))] | length' 2>/dev/null || echo "0")

            if [ "$EXISTING_ISSUE" -gt 0 ]; then
              echo "  Issue already exists for run $RUN_ID"
              continue
            fi

            echo "  Creating issue for failed $RUN_NAME workflow..."

            ISSUE_FILE=$(mktemp)
            {
              echo "## CI Failure on main branch"
              echo ""
              echo "**Workflow:** $RUN_NAME"
              echo "**Run ID:** $RUN_ID"
              echo "**Branch:** main"
              echo ""
              echo "[View failed run](https://github.com/${{ github.repository }}/actions/runs/$RUN_ID)"
              echo ""
              echo "---"
              echo "_Auto-created by Factory Manager. CI Monitor may have missed this._"
            } > "$ISSUE_FILE"

            NEW_ISSUE_URL=$(gh issue create \
              --repo ${{ github.repository }} \
              --title "CI Failure: $RUN_NAME on main" \
              --label "bug,priority-high,ci-failure" \
              --body-file "$ISSUE_FILE" 2>/dev/null || echo "")
            rm -f "$ISSUE_FILE"

            # Post comment to trigger Code Agent (body @code doesn't trigger, comments do)
            if [ -n "$NEW_ISSUE_URL" ]; then
              NEW_ISSUE_NUM=$(echo "$NEW_ISSUE_URL" | grep -oE '[0-9]+$')
              if [ -n "$NEW_ISSUE_NUM" ]; then
                gh issue comment "$NEW_ISSUE_NUM" --repo ${{ github.repository }} \
                  --body "@code please investigate this CI failure and fix it." 2>/dev/null || true
              fi
            fi
          done

      - name: Trigger Code Agent on untriggered issues
        if: steps.untriggered.outputs.has_untriggered == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          UNTRIGGERED_ISSUES: ${{ steps.untriggered.outputs.untriggered_issues }}
        run: |
          echo "Triggering Code Agent on issues that need it..."

          TRIGGERED_COUNT=0
          MAX_TRIGGER=3

          echo "$UNTRIGGERED_ISSUES" | jq -c '.[]' | head -$MAX_TRIGGER | while read -r issue; do
            ISSUE_NUM=$(echo "$issue" | jq -r '.number')
            ISSUE_TITLE=$(echo "$issue" | jq -r '.title')

            echo "Triggering Code Agent on issue #$ISSUE_NUM: $ISSUE_TITLE"

            TRIGGER_FILE=$(mktemp)
            {
              echo "@code [Factory Manager] This issue has been triaged but no agent has started work. Please investigate and implement."
              echo ""
              echo "_Auto-triggered by Factory Manager because no @code mention was found after 15 minutes._"
            } > "$TRIGGER_FILE"

            gh issue comment "$ISSUE_NUM" --repo ${{ github.repository }} --body-file "$TRIGGER_FILE"
            rm -f "$TRIGGER_FILE"
            TRIGGERED_COUNT=$((TRIGGERED_COUNT + 1))
          done

          echo "Triggered Code Agent on $TRIGGERED_COUNT issues"

      - name: Re-triage unlabeled issues
        if: steps.unlabeled.outputs.has_unlabeled == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          UNLABELED_ISSUES: ${{ steps.unlabeled.outputs.unlabeled_issues }}
        run: |
          echo "Re-triggering triage for unlabeled issues..."

          RETRIAGE_COUNT=0
          MAX_RETRIAGE=3

          echo "$UNLABELED_ISSUES" | jq -c '.[]' | head -$MAX_RETRIAGE | while read -r issue; do
            ISSUE_NUM=$(echo "$issue" | jq -r '.number')
            ISSUE_TITLE=$(echo "$issue" | jq -r '.title')

            echo "Re-triggering triage for issue #$ISSUE_NUM: $ISSUE_TITLE"

            # Check if Factory Manager already commented recently
            RECENT_FM_COMMENT=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUM/comments \
              --jq '[.[] | select(
                (.body | contains("[Factory Manager]")) and
                ((.created_at | fromdateiso8601) > (now - 3600))
              )] | length' 2>/dev/null || echo "0")

            if [ "$RECENT_FM_COMMENT" -gt 0 ]; then
              echo "  Already commented recently, skipping"
              continue
            fi

            RETRIAGE_FILE=$(mktemp)
            {
              echo "@triage [Factory Manager] This issue has no labels - triage may have failed. Please re-triage."
              echo ""
              echo "_Auto-triggered by Factory Manager because issue had no labels after 15 minutes._"
            } > "$RETRIAGE_FILE"

            gh issue comment "$ISSUE_NUM" --repo ${{ github.repository }} --body-file "$RETRIAGE_FILE"
            rm -f "$RETRIAGE_FILE"
            RETRIAGE_COUNT=$((RETRIAGE_COUNT + 1))
          done

          echo "Re-triggered triage on $RETRIAGE_COUNT issues"

      - name: Log health check results
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          STUCK_COUNT: ${{ steps.stuck.outputs.has_stuck == 'true' && '1' || '0' }}
          LONGRUNNING_COUNT: ${{ steps.longrunning.outputs.has_longrunning == 'true' && '1' || '0' }}
          FAILED_COUNT: ${{ steps.failed.outputs.has_failed == 'true' && '1' || '0' }}
          STUCK_PRS_COUNT: ${{ steps.stuck_prs.outputs.has_stuck_prs == 'true' && '1' || '0' }}
          LONGRUNNING_CI_COUNT: ${{ steps.longrunning_ci.outputs.has_longrunning_ci == 'true' && '1' || '0' }}
          UNTRIGGERED_COUNT: ${{ steps.untriggered.outputs.has_untriggered == 'true' && '1' || '0' }}
          UNLABELED_COUNT: ${{ steps.unlabeled.outputs.has_unlabeled == 'true' && '1' || '0' }}
        run: |
          echo "=== Factory Health Check Complete ==="
          echo "Stuck issues found: $STUCK_COUNT"
          echo "Long-running issues found: $LONGRUNNING_COUNT"
          echo "Failed workflows found: $FAILED_COUNT"
          echo "Stuck PRs with failing CI: $STUCK_PRS_COUNT"
          echo "Long-running E2E tests (>10 min): $LONGRUNNING_CI_COUNT"
          echo "Untriggered triaged issues: $UNTRIGGERED_COUNT"
          echo "Unlabeled issues (failed triage): $UNLABELED_COUNT"
          echo ""
          echo "Next check in 5 minutes"

  # ===========================================
  # WEEKLY REPORT (Monday 6am UTC)
  # ===========================================
  weekly-report:
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 6 * * 1') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'weekly-report')
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4

      - name: Gather metrics
        id: metrics
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Gathering weekly metrics..."

          # Date range for this week
          WEEK_AGO=$(date -u -d '7 days ago' '+%Y-%m-%dT%H:%M:%SZ')
          TODAY=$(date -u '+%Y-%m-%d')

          # Count issues created this week
          CREATED=$(gh issue list \
            --repo ${{ github.repository }} \
            --state all \
            --json number,createdAt \
            --jq --arg since "$WEEK_AGO" '[.[] | select(.createdAt > $since)] | length' 2>/dev/null || echo "0")

          # Count issues closed this week
          CLOSED=$(gh issue list \
            --repo ${{ github.repository }} \
            --state closed \
            --json number,closedAt \
            --jq --arg since "$WEEK_AGO" '[.[] | select(.closedAt > $since)] | length' 2>/dev/null || echo "0")

          # Count PRs merged this week
          MERGED=$(gh pr list \
            --repo ${{ github.repository }} \
            --state merged \
            --json number,mergedAt \
            --jq --arg since "$WEEK_AGO" '[.[] | select(.mergedAt > $since)] | length' 2>/dev/null || echo "0")

          # Count factory-incident issues this week
          INCIDENTS=$(gh issue list \
            --repo ${{ github.repository }} \
            --label "factory-incident" \
            --state all \
            --json number,createdAt \
            --jq --arg since "$WEEK_AGO" '[.[] | select(.createdAt > $since)] | length' 2>/dev/null || echo "0")

          # Count escalations (needs-human added this week)
          ESCALATED=$(gh issue list \
            --repo ${{ github.repository }} \
            --label "needs-human" \
            --state all \
            --json number \
            --jq 'length' 2>/dev/null || echo "0")

          # Current open issues
          OPEN=$(gh issue list \
            --repo ${{ github.repository }} \
            --state open \
            --json number \
            --jq 'length' 2>/dev/null || echo "0")

          echo "report_date=$TODAY" >> $GITHUB_OUTPUT
          echo "created=$CREATED" >> $GITHUB_OUTPUT
          echo "closed=$CLOSED" >> $GITHUB_OUTPUT
          echo "merged=$MERGED" >> $GITHUB_OUTPUT
          echo "incidents=$INCIDENTS" >> $GITHUB_OUTPUT
          echo "escalated=$ESCALATED" >> $GITHUB_OUTPUT
          echo "open=$OPEN" >> $GITHUB_OUTPUT

      - name: Create weekly report issue
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          REPORT_DATE: ${{ steps.metrics.outputs.report_date }}
          CREATED: ${{ steps.metrics.outputs.created }}
          CLOSED: ${{ steps.metrics.outputs.closed }}
          MERGED: ${{ steps.metrics.outputs.merged }}
          INCIDENTS: ${{ steps.metrics.outputs.incidents }}
          ESCALATED: ${{ steps.metrics.outputs.escalated }}
          OPEN: ${{ steps.metrics.outputs.open }}
        run: |
          # Calculate success rate (closed / created, capped at 100%)
          if [ "$CREATED" -gt 0 ]; then
            SUCCESS_RATE=$(( (CLOSED * 100) / CREATED ))
            [ "$SUCCESS_RATE" -gt 100 ] && SUCCESS_RATE=100
          else
            SUCCESS_RATE=100
          fi

          # Determine health status
          if [ "$INCIDENTS" -gt 5 ] || [ "$ESCALATED" -gt 10 ]; then
            HEALTH_STATUS="NEEDS_ATTENTION"
            HEALTH_EMOJI="Warning"
          elif [ "$INCIDENTS" -gt 2 ] || [ "$ESCALATED" -gt 5 ]; then
            HEALTH_STATUS="FAIR"
            HEALTH_EMOJI="Yellow circle"
          else
            HEALTH_STATUS="HEALTHY"
            HEALTH_EMOJI="Green circle"
          fi

          # Build report using printf to avoid YAML multiline issues
          INCIDENTS_STATUS=$([ "$INCIDENTS" -le 2 ] && echo 'OK' || echo 'Elevated')
          ESCALATED_STATUS=$([ "$ESCALATED" -le 5 ] && echo 'OK' || echo 'Elevated')
          RATE_STATUS=$([ "$SUCCESS_RATE" -ge 70 ] && echo 'OK' || echo 'Low')

          {
            echo "## Factory Health Report - Week of $REPORT_DATE"
            echo ""
            echo "### Overall Status: $HEALTH_STATUS"
            echo ""
            echo "### Issue Flow"
            echo ""
            echo "| Metric | Count |"
            echo "|--------|-------|"
            echo "| Issues Created | $CREATED |"
            echo "| Issues Closed | $CLOSED |"
            echo "| PRs Merged | $MERGED |"
            echo "| Currently Open | $OPEN |"
            echo ""
            echo "### Factory Health"
            echo ""
            echo "| Metric | Count | Status |"
            echo "|--------|-------|--------|"
            echo "| Factory Incidents | $INCIDENTS | $INCIDENTS_STATUS |"
            echo "| Escalations (needs-human) | $ESCALATED | $ESCALATED_STATUS |"
            echo "| Resolution Rate | ${SUCCESS_RATE}% | $RATE_STATUS |"
            echo ""
            echo "### Workflow Health"
            echo ""
            echo "Check the [Actions tab](https://github.com/${{ github.repository }}/actions) for workflow run details."
            echo ""
            echo "_This report is automatically generated by the Factory Manager every Monday._"
            echo "_For questions or to investigate issues, mention @factory-manager on any issue._"
          } | gh issue create \
            --repo ${{ github.repository }} \
            --title "Factory Health Report - Week of $REPORT_DATE" \
            --label "factory-meta,factory-health" \
            --body-file -

          echo "Weekly report created!"

  # ===========================================
  # RESPOND TO @factory-manager MENTIONS
  # ===========================================
  respond:
    if: |
      github.event_name == 'issue_comment' &&
      !github.event.issue.pull_request &&
      (contains(github.event.comment.body, '@factory-manager') ||
       contains(github.event.comment.body, '@Factory-Manager'))
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v6

      - name: Set up Python
        run: uv python install 3.11

      - name: Acknowledge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          {
            echo "## Factory Manager Responding"
            echo ""
            echo "**Status:** Analyzing this issue and the factory state..."
            echo "**Workflow:** [View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          } | gh issue comment ${{ github.event.issue.number }} \
            --repo ${{ github.repository }} \
            --body-file -

      - name: Pre-install Claude Code
        run: |
          rm -f "$HOME/.claude/.installing" "$HOME/.claude/install.lock" 2>/dev/null || true
          curl -fsSL https://claude.ai/install.sh | bash -s -- 2.0.74
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          echo "$HOME/.claude/bin" >> $GITHUB_PATH

      - name: Run Claude for diagnosis
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            You are the Factory Manager - a meta-agent responsible for monitoring and maintaining the autonomous software factory.

            Read CLAUDE.md and docs/FACTORY_MANAGER.md first.

            A user has mentioned @factory-manager on issue #${{ github.event.issue.number }}.

            ## Your Role
            You diagnose and fix FACTORY issues (how agents work together), not PRODUCT issues (application bugs).

            ## Step 1: Understand the Request
            Read the issue and comment:
            ```bash
            gh issue view ${{ github.event.issue.number }} --comments
            ```

            Determine: Is this a factory issue or a product issue?
            - Factory: Agent triggers, workflow failures, stuck issues, escalation problems
            - Product: Application bugs, feature requests, UI issues

            ## Step 2: If Factory Issue - Diagnose

            Check for common problems:
            1. **Stuck triggers**: Did the right agent get triggered?
               ```bash
               gh run list --workflow=bug-fix.yml --limit 5
               ```

            2. **Label issues**: Are labels correct?
               ```bash
               gh issue view ${{ github.event.issue.number }} --json labels
               ```

            3. **Workflow failures**: Any recent failures?
               ```bash
               gh run list --status failure --limit 10
               ```

            4. **Progress tracking**: Is progress being tracked?
               Check for progress comments on the issue.

            ## Step 3: Take Action

            If you find a factory issue:
            1. Diagnose the root cause
            2. Attempt to fix (re-trigger agent, fix labels, etc.)
            3. Post your findings and actions

            If it's a product issue:
            1. Politely explain this is for factory issues
            2. Suggest using @code for product issues

            ## Output Format

            Post a comment with:
            - Your diagnosis
            - Actions taken
            - Recommendations

          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_args: |
            --model claude-sonnet-4-20250514
            --dangerously-skip-permissions
            --allowedTools "Bash(gh:*),Read,Glob,Grep"
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          GITHUB_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}

  # ===========================================
  # TRIGGER VERIFICATION (weekly or manual)
  # ===========================================
  trigger-verification:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'trigger-verification'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4

      - name: Create test issue
        id: test
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
        run: |
          echo "Creating trigger verification test issue..."

          # Create issue body using heredoc to temp file
          TEST_BODY_FILE=$(mktemp)
          cat > "$TEST_BODY_FILE" << 'TESTBODYEOF'
          ## Trigger Verification Test

          This is an automated test to verify that agent triggers are working correctly.

          **Test Plan:**
          1. This issue was created with `factory-meta` + `bug` labels
          2. Adding `ai-ready` label should NOT trigger Code Agent (factory-meta exclusion)
          3. If Code Agent triggers, that's a bug in the trigger logic

          **Expected:** No agent activity on this issue.

          _Automated test by Factory Manager_
          TESTBODYEOF

          ISSUE_URL=$(gh issue create \
            --repo ${{ github.repository }} \
            --title "[Factory Test] Trigger Verification - $(date '+%Y-%m-%d %H:%M')" \
            --label "factory-meta,bug" \
            --body-file "$TEST_BODY_FILE")
          rm -f "$TEST_BODY_FILE"

          ISSUE_NUM=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')
          echo "issue_number=$ISSUE_NUM" >> $GITHUB_OUTPUT
          echo "Created test issue #$ISSUE_NUM"

      - name: Add ai-ready label
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          ISSUE_NUMBER: ${{ steps.test.outputs.issue_number }}
        run: |
          echo "Adding ai-ready label to test issue..."
          gh issue edit "$ISSUE_NUMBER" \
            --repo ${{ github.repository }} \
            --add-label "ai-ready"

          echo "Waiting 30 seconds to see if agent triggers..."
          sleep 30

      - name: Check for agent activity
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          ISSUE_NUMBER: ${{ steps.test.outputs.issue_number }}
        run: |
          # Check if any bot commented
          BOT_COMMENTS=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUMBER/comments \
            --jq '[.[] | select(.user.login | endswith("[bot]"))] | length' 2>/dev/null || echo "0")

          if [ "$BOT_COMMENTS" -gt 0 ]; then
            echo "FAIL: Agent triggered on factory-meta issue!"
            {
              echo "## Trigger Test FAILED"
              echo ""
              echo "An agent triggered on this \`factory-meta\` issue when it should have been excluded."
              echo ""
              echo "**This indicates a bug** in the agent trigger logic. The bug-fix.yml workflow needs to be updated to exclude \`factory-meta\` labels."
            } | gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} --body-file -
            exit 1
          else
            echo "PASS: No agent triggered (correct behavior)"
            {
              echo "## Trigger Test PASSED"
              echo ""
              echo "No agent triggered on this \`factory-meta\` issue, which is the correct behavior."
              echo ""
              echo "Closing this test issue."
            } | gh issue comment "$ISSUE_NUMBER" --repo ${{ github.repository }} --body-file -
            gh issue close "$ISSUE_NUMBER" --repo ${{ github.repository }}
          fi

  # ===========================================
  # DIAGNOSE SPECIFIC ISSUE (manual)
  # ===========================================
  diagnose-issue:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'diagnose-issue'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v6

      - name: Set up Python
        run: uv python install 3.11

      - name: Pre-install Claude Code
        run: |
          rm -f "$HOME/.claude/.installing" "$HOME/.claude/install.lock" 2>/dev/null || true
          curl -fsSL https://claude.ai/install.sh | bash -s -- 2.0.74
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          echo "$HOME/.claude/bin" >> $GITHUB_PATH

      - name: Run Claude for deep diagnosis
        uses: anthropics/claude-code-action@v1
        with:
          prompt: |
            You are the Factory Manager performing a deep diagnosis of issue #${{ github.event.inputs.issue_number }}.

            Read CLAUDE.md and docs/FACTORY_MANAGER.md first.

            ## Step 1: Gather Context

            ```bash
            # Read the issue
            gh issue view ${{ github.event.inputs.issue_number }} --comments

            # Check related PRs
            gh pr list --search "head:fix/${{ github.event.inputs.issue_number }}" --state all
            gh pr list --search "head:feat/${{ github.event.inputs.issue_number }}" --state all

            # Check workflow runs
            gh run list --limit 20 --json databaseId,name,status,conclusion,headBranch
            ```

            ## Step 2: Diagnose

            Look for:
            1. Was the issue properly labeled?
            2. Did the right agents trigger?
            3. Were there workflow failures?
            4. Was progress tracked?
            5. Why did it get stuck (if stuck)?

            ## Step 3: Report

            Create a detailed diagnosis comment on the issue with:
            - Timeline of events
            - What went wrong
            - Root cause
            - Recommended fix

          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_args: |
            --model claude-opus-4-5-20251101
            --dangerously-skip-permissions
            --allowedTools "Bash(gh:*),Read,Glob,Grep"
        env:
          GH_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
          GITHUB_TOKEN: ${{ secrets.PAT_WITH_WORKFLOW_ACCESS }}
